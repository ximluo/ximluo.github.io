{"version":3,"file":"static/js/24.66fcec12.chunk.js","mappings":"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U,YAAYwZ,EAChE,OAAQvf,GACPF,QAAQE,MAAMA,GAEd4e,KAAKvE,YAAY,CAAE53B,KAAM,QAAS63B,GAAIC,EAAQD,GAAIta,MAAOA,EAAMua,SAC3E,SACYgC,EAAM+C,QAAQvB,GACdxB,EAAM+C,QAAQ9C,EACf,KAIR,CAgHH,CC5bA,IAAIiD,EAEJ,MAAMC,EAAiBA,KACjB,GAAAD,EAAkB,OAAAA,EAItB,MAMME,EAAW,IAAI96B,WAAW,CAC9B,EACA,GACA,IACA,IACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,EACA,EACA,GACA,GACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,GACA,EACA,IACA,GACA,EACA,EACA,GACA,EACA,EACA,GACA,EACA,IACA,GACA,GACA,KAII+6B,EAAW,IAAI/6B,WAAW,CAC9B,GACA,EACA,GACA,IACA,EACA,EACA,EACA,GACA,EACA,IACA,EACA,EACA,GACA,EACA,EACA,GACA,GACA,GACA,GACA,GACA,IACA,EACA,IACA,GACA,GACA,IACA,IACA,GACA,GACA,GACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,GACA,IACA,GACA,IACA,IACA,IACA,GACA,GACA,IACA,IACA,IACA,GACA,GACA,IACA,GACA,GACA,GACA,IACA,IACA,GACA,MAGE,GAAuB,kBAAhBw2B,YAEF,OACLwE,WAAW,GAIf,IAMIC,EANAC,EAlIF,gsOAoIE1E,YAAY2E,SAASL,KAChBI,EAnIP,ghUAwII,MAAAlG,EAAUwB,YAAY4E,YAK5B,SAAgB54B,GACd,MAAM64B,EAAS,IAAIr7B,WAAWwC,EAAKxH,QACnC,IAAK,IAAI0D,EAAI,EAAGA,EAAI8D,EAAKxH,SAAU0D,EAAG,CAC9B,MAAA48B,EAAK94B,EAAK+4B,WAAW78B,GAC3B28B,EAAO38B,GAAK48B,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EA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","sources":["../node_modules/@react-three/drei/core/useAnimations.js","../node_modules/@babel/runtime/helpers/esm/extends.js","../node_modules/src/objects/GroundProjectedEnv.ts","../node_modules/src/loaders/RGBELoader.js","../node_modules/three-stdlib/node_modules/fflate/esm/browser.js","../node_modules/src/loaders/EXRLoader.js","../node_modules/@monogrid/gainmap-js/dist/QuadRenderer-DuOPRGA4.js","../node_modules/@monogrid/gainmap-js/dist/decode.js","../node_modules/@react-three/drei/helpers/environment-assets.js","../node_modules/@react-three/drei/core/useEnvironment.js","../node_modules/@react-three/drei/core/Environment.js","../node_modules/src/loaders/DRACOLoader.js","../node_modules/src/libs/MeshoptDecoder.ts","../node_modules/src/utils/BufferGeometryUtils.ts","../node_modules/src/_polyfill/LoaderUtils.js","../node_modules/src/loaders/GLTFLoader.js","../node_modules/@react-three/drei/core/Gltf.js","../node_modules/src/_polyfill/constants.ts"],"sourcesContent":["import * as React from 'react';\nimport { Object3D, AnimationMixer } from 'three';\nimport { useFrame } from '@react-three/fiber';\n\nfunction useAnimations(clips, root) {\n  const ref = React.useRef(null);\n  const [actualRef] = React.useState(() => root ? root instanceof Object3D ? {\n    current: root\n  } : root : ref);\n  const [mixer] = React.useState(() => new AnimationMixer(undefined));\n  React.useLayoutEffect(() => {\n    if (root) actualRef.current = root instanceof Object3D ? root : root.current;\n    mixer._root = actualRef.current;\n  });\n  const lazyActions = React.useRef({});\n  const api = React.useMemo(() => {\n    const actions = {};\n    clips.forEach(clip => Object.defineProperty(actions, clip.name, {\n      enumerable: true,\n      get() {\n        if (actualRef.current) {\n          return lazyActions.current[clip.name] || (lazyActions.current[clip.name] = mixer.clipAction(clip, actualRef.current));\n        }\n      },\n      configurable: true\n    }));\n    return {\n      ref: actualRef,\n      clips,\n      actions,\n      names: clips.map(c => c.name),\n      mixer\n    };\n  }, [clips]);\n  useFrame((state, delta) => mixer.update(delta));\n  React.useEffect(() => {\n    const currentRoot = actualRef.current;\n    return () => {\n      // Clean up only when clips change, wipe out lazy actions and uncache clips\n      lazyActions.current = {};\n      mixer.stopAllAction();\n      Object.values(api.actions).forEach(action => {\n        if (currentRoot) {\n          mixer.uncacheAction(action, currentRoot);\n        }\n      });\n    };\n  }, [clips]);\n  return api;\n}\n\nexport { useAnimations };\n","function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nexport { _extends as default };","import { Mesh, IcosahedronGeometry, ShaderMaterial, DoubleSide, Texture, CubeTexture, BufferGeometry } from 'three'\nimport { version } from '../_polyfill/constants'\n\nexport interface GroundProjectedEnvParameters {\n  height?: number\n  radius?: number\n}\n\nconst isCubeTexture = (def: CubeTexture | Texture): def is CubeTexture => def && (def as CubeTexture).isCubeTexture\n\nexport class GroundProjectedEnv extends Mesh<BufferGeometry, ShaderMaterial> {\n  constructor(texture: CubeTexture | Texture, options?: GroundProjectedEnvParameters) {\n    const isCubeMap = isCubeTexture(texture)\n    const w = (isCubeMap ? texture.image[0]?.width : texture.image.width) ?? 1024\n    const cubeSize = w / 4\n    const _lodMax = Math.floor(Math.log2(cubeSize))\n    const _cubeSize = Math.pow(2, _lodMax)\n    const width = 3 * Math.max(_cubeSize, 16 * 7)\n    const height = 4 * _cubeSize\n\n    const defines = [\n      isCubeMap ? '#define ENVMAP_TYPE_CUBE' : '',\n      `#define CUBEUV_TEXEL_WIDTH ${1.0 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1.0 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`,\n    ]\n\n    const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    const fragmentShader =\n      defines.join('\\n') +\n      /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n        }\n        `\n\n    const uniforms = {\n      map: { value: texture },\n      height: { value: options?.height || 15 },\n      radius: { value: options?.radius || 100 },\n    }\n\n    const geometry = new IcosahedronGeometry(1, 16)\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide,\n    })\n\n    super(geometry, material)\n  }\n\n  set radius(radius: number) {\n    this.material.uniforms.radius.value = radius\n  }\n\n  get radius(): number {\n    return this.material.uniforms.radius.value\n  }\n\n  set height(height: number) {\n    this.material.uniforms.height.value = height\n  }\n\n  get height(): number {\n    return this.material.uniforms.height.value\n  }\n}\n","import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearFilter } from 'three'\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n  parse(buffer) {\n    const /* default error routine.  change this to change error handling */\n      rgbe_read_error = 1,\n      rgbe_write_error = 2,\n      rgbe_format_error = 3,\n      rgbe_memory_error = 4,\n      rgbe_error = function (rgbe_error_code, msg) {\n        switch (rgbe_error_code) {\n          case rgbe_read_error:\n            throw new Error('THREE.RGBELoader: Read Error: ' + (msg || ''))\n          case rgbe_write_error:\n            throw new Error('THREE.RGBELoader: Write Error: ' + (msg || ''))\n          case rgbe_format_error:\n            throw new Error('THREE.RGBELoader: Bad File Format: ' + (msg || ''))\n          default:\n          case rgbe_memory_error:\n            throw new Error('THREE.RGBELoader: Memory Error: ' + (msg || ''))\n        }\n      },\n      /* offsets to red, green, and blue components in a data (float) pixel */\n      //RGBE_DATA_RED = 0,\n      //RGBE_DATA_GREEN = 1,\n      //RGBE_DATA_BLUE = 2,\n\n      /* number of floats per pixel, use 4 since stored in rgba image format */\n      //RGBE_DATA_SIZE = 4,\n\n      /* flags indicating which fields in an rgbe_header_info are valid */\n      RGBE_VALID_PROGRAMTYPE = 1,\n      RGBE_VALID_FORMAT = 2,\n      RGBE_VALID_DIMENSIONS = 4,\n      NEWLINE = '\\n',\n      fgets = function (buffer, lineLimit, consume) {\n        const chunkSize = 128\n\n        lineLimit = !lineLimit ? 1024 : lineLimit\n        let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n\n        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n          s += chunk\n          len += chunk.length\n          p += chunkSize\n          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n        }\n\n        if (-1 < i) {\n          /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n          if (false !== consume) buffer.pos += len + i + 1\n          return s + chunk.slice(0, i)\n        }\n\n        return false\n      },\n      /* minimal header reading.  modify if you want to parse more information */\n      RGBE_ReadHeader = function (buffer) {\n        // regexes to parse header info fields\n        const magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n          header = {\n            valid: 0 /* indicate which fields are valid */,\n\n            string: '' /* the actual header string */,\n\n            comments: '' /* comments found in header */,\n\n            programtype: 'RGBE' /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */,\n\n            format: '' /* RGBE format, default 32-bit_rle_rgbe */,\n\n            gamma: 1.0 /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */,\n\n            exposure: 1.0 /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */,\n\n            width: 0,\n            height: 0 /* image dimensions, width/height */,\n          }\n\n        let line, match\n\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n          rgbe_error(rgbe_read_error, 'no header found')\n        }\n\n        /* if you want to require the magic token then uncomment the next line */\n        if (!(match = line.match(magic_token_re))) {\n          rgbe_error(rgbe_format_error, 'bad initial token')\n        }\n\n        header.valid |= RGBE_VALID_PROGRAMTYPE\n        header.programtype = match[1]\n        header.string += line + '\\n'\n\n        while (true) {\n          line = fgets(buffer)\n          if (false === line) break\n          header.string += line + '\\n'\n\n          if ('#' === line.charAt(0)) {\n            header.comments += line + '\\n'\n            continue // comment line\n          }\n\n          if ((match = line.match(gamma_re))) {\n            header.gamma = parseFloat(match[1])\n          }\n\n          if ((match = line.match(exposure_re))) {\n            header.exposure = parseFloat(match[1])\n          }\n\n          if ((match = line.match(format_re))) {\n            header.valid |= RGBE_VALID_FORMAT\n            header.format = match[1] //'32-bit_rle_rgbe';\n          }\n\n          if ((match = line.match(dimensions_re))) {\n            header.valid |= RGBE_VALID_DIMENSIONS\n            header.height = parseInt(match[1], 10)\n            header.width = parseInt(match[2], 10)\n          }\n\n          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break\n        }\n\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\n          rgbe_error(rgbe_format_error, 'missing format specifier')\n        }\n\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n          rgbe_error(rgbe_format_error, 'missing image size specifier')\n        }\n\n        return header\n      },\n      RGBE_ReadPixels_RLE = function (buffer, w, h) {\n        const scanline_width = w\n\n        if (\n          // run length encoding is not allowed so read flat\n          scanline_width < 8 ||\n          scanline_width > 0x7fff ||\n          // this file is not run length encoded\n          2 !== buffer[0] ||\n          2 !== buffer[1] ||\n          buffer[2] & 0x80\n        ) {\n          // return the flat buffer\n          return new Uint8Array(buffer)\n        }\n\n        if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {\n          rgbe_error(rgbe_format_error, 'wrong scanline width')\n        }\n\n        const data_rgba = new Uint8Array(4 * w * h)\n\n        if (!data_rgba.length) {\n          rgbe_error(rgbe_memory_error, 'unable to allocate buffer space')\n        }\n\n        let offset = 0,\n          pos = 0\n\n        const ptr_end = 4 * scanline_width\n        const rgbeStart = new Uint8Array(4)\n        const scanline_buffer = new Uint8Array(ptr_end)\n        let num_scanlines = h\n\n        // read in each successive scanline\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\n          if (pos + 4 > buffer.byteLength) {\n            rgbe_error(rgbe_read_error)\n          }\n\n          rgbeStart[0] = buffer[pos++]\n          rgbeStart[1] = buffer[pos++]\n          rgbeStart[2] = buffer[pos++]\n          rgbeStart[3] = buffer[pos++]\n\n          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || ((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width) {\n            rgbe_error(rgbe_format_error, 'bad rgbe scanline format')\n          }\n\n          // read each of the four channels for the scanline into the buffer\n          // first red, then green, then blue, then exponent\n          let ptr = 0,\n            count\n\n          while (ptr < ptr_end && pos < buffer.byteLength) {\n            count = buffer[pos++]\n            const isEncodedRun = count > 128\n            if (isEncodedRun) count -= 128\n\n            if (0 === count || ptr + count > ptr_end) {\n              rgbe_error(rgbe_format_error, 'bad scanline data')\n            }\n\n            if (isEncodedRun) {\n              // a (encoded) run of the same value\n              const byteValue = buffer[pos++]\n              for (let i = 0; i < count; i++) {\n                scanline_buffer[ptr++] = byteValue\n              }\n              //ptr += count;\n            } else {\n              // a literal-run\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr)\n              ptr += count\n              pos += count\n            }\n          }\n\n          // now convert data from buffer into rgba\n          // first red, then green, then blue, then exponent (alpha)\n          const l = scanline_width //scanline_buffer.byteLength;\n          for (let i = 0; i < l; i++) {\n            let off = 0\n            data_rgba[offset] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 1] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 2] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 3] = scanline_buffer[i + off]\n            offset += 4\n          }\n\n          num_scanlines--\n        }\n\n        return data_rgba\n      }\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale\n      destArray[destOffset + 3] = 1\n    }\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      // clamping to 65504, the maximum representable value in float16\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504))\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504))\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504))\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1)\n    }\n\n    const byteArray = new Uint8Array(buffer)\n    byteArray.pos = 0\n    const rgbe_header_info = RGBE_ReadHeader(byteArray)\n\n    const w = rgbe_header_info.width,\n      h = rgbe_header_info.height,\n      image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h)\n\n    let data, type\n    let numElements\n\n    switch (this.type) {\n      case FloatType:\n        numElements = image_rgba_data.length / 4\n        const floatArray = new Float32Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4)\n        }\n\n        data = floatArray\n        type = FloatType\n        break\n\n      case HalfFloatType:\n        numElements = image_rgba_data.length / 4\n        const halfArray = new Uint16Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4)\n        }\n\n        data = halfArray\n        type = HalfFloatType\n        break\n\n      default:\n        throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type)\n        break\n    }\n\n    return {\n      width: w,\n      height: h,\n      data: data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type: type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n        case HalfFloatType:\n          if ('colorSpace' in texture) texture.colorSpace = 'srgb-linear'\n          else texture.encoding = 3000 // LinearEncoding\n          texture.minFilter = LinearFilter\n          texture.magFilter = LinearFilter\n          texture.generateMipmaps = false\n          texture.flipY = true\n\n          break\n      }\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { RGBELoader }\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: 'text/javascript' }))));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","import {\n  Texture,\n  DataTextureLoader,\n  DataUtils,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  RedFormat,\n  RGBAFormat,\n} from 'three'\nimport { unzlibSync } from 'fflate'\nimport { version } from '../_polyfill/constants'\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\n// https://github.com/mrdoob/three.js/pull/25771\nconst hasColorSpace = version >= 152\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16\n    const BITMAP_SIZE = USHORT_RANGE >> 3\n\n    const HUF_ENCBITS = 16 // literal (value) bit length\n    const HUF_DECBITS = 14 // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1 // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1\n\n    const NBITS = 16\n    const A_OFFSET = 1 << (NBITS - 1)\n    const MOD_MASK = (1 << NBITS) - 1\n\n    const SHORT_ZEROCODE_RUN = 59\n    const LONG_ZEROCODE_RUN = 63\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN\n\n    const ULONG_SIZE = 8\n    const FLOAT32_SIZE = 4\n    const INT32_SIZE = 4\n    const INT16_SIZE = 2\n    const INT8_SIZE = 1\n\n    const STATIC_HUFFMAN = 0\n    const DEFLATE = 1\n\n    const UNKNOWN = 0\n    const LOSSY_DCT = 1\n    const RLE = 2\n\n    const logBase = Math.pow(2.7182818, 2.2)\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\n          lut[k++] = i\n        }\n      }\n\n      var n = k - 1\n\n      while (k < USHORT_RANGE) lut[k++] = 0\n\n      return n\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {}\n        hdec[i].len = 0\n        hdec[i].lit = 0\n        hdec[i].p = null\n      }\n    }\n\n    const getBitsReturn = { l: 0, c: 0, lc: 0 }\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n        lc += 8\n      }\n\n      lc -= nBits\n\n      getBitsReturn.l = (c >> lc) & ((1 << nBits) - 1)\n      getBitsReturn.c = c\n      getBitsReturn.lc = lc\n    }\n\n    const hufTableBuffer = new Array(59)\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1\n\n      var c = 0\n\n      for (var i = 58; i > 0; --i) {\n        var nc = (c + hufTableBuffer[i]) >> 1\n        hufTableBuffer[i] = c\n        c = nc\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i]\n        if (l > 0) hcode[i] = l | (hufTableBuffer[l]++ << 6)\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset\n      var c = 0\n      var lc = 0\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false\n\n        getBits(6, c, lc, uInt8Array, p)\n\n        var l = getBitsReturn.l\n        c = getBitsReturn.c\n        lc = getBitsReturn.lc\n\n        hcode[im] = l\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          getBits(8, c, lc, uInt8Array, p)\n\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN\n          c = getBitsReturn.c\n          lc = getBitsReturn.lc\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        }\n      }\n\n      hufCanonicalCodeTable(hcode)\n    }\n\n    function hufLength(code) {\n      return code & 63\n    }\n\n    function hufCode(code) {\n      return code >> 6\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im])\n        var l = hufLength(hcode[im])\n\n        if (c >> l) {\n          throw 'Invalid table entry'\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> (l - HUF_DECBITS)]\n\n          if (pl.len) {\n            throw 'Invalid table entry'\n          }\n\n          pl.lit++\n\n          if (pl.p) {\n            var p = pl.p\n            pl.p = new Array(pl.lit)\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i]\n            }\n          } else {\n            pl.p = new Array(1)\n          }\n\n          pl.p[pl.lit - 1] = im\n        } else if (l) {\n          var plOffset = 0\n\n          for (var i = 1 << (HUF_DECBITS - l); i > 0; i--) {\n            var pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset]\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry'\n            }\n\n            pl.len = l\n            pl.lit = im\n\n            plOffset++\n          }\n        }\n      }\n\n      return true\n    }\n\n    const getCharReturn = { c: 0, lc: 0 }\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n      lc += 8\n\n      getCharReturn.c = c\n      getCharReturn.lc = lc\n    }\n\n    const getCodeReturn = { c: 0, lc: 0 }\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset)\n          c = getCharReturn.c\n          lc = getCharReturn.lc\n        }\n\n        lc -= 8\n\n        var cs = c >> lc\n        var cs = new Uint8Array([cs])[0]\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1]\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po\n      } else {\n        return false\n      }\n\n      getCodeReturn.c = c\n      getCodeReturn.lc = lc\n    }\n\n    function UInt16(value) {\n      return value & 0xffff\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value)\n      return ref > 0x7fff ? ref - 0x10000 : ref\n    }\n\n    const wdec14Return = { a: 0, b: 0 }\n\n    function wdec14(l, h) {\n      var ls = Int16(l)\n      var hs = Int16(h)\n\n      var hi = hs\n      var ai = ls + (hi & 1) + (hi >> 1)\n\n      var as = ai\n      var bs = ai - hi\n\n      wdec14Return.a = as\n      wdec14Return.b = bs\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l)\n      var d = UInt16(h)\n\n      var bb = (m - (d >> 1)) & MOD_MASK\n      var aa = (d + bb - A_OFFSET) & MOD_MASK\n\n      wdec14Return.a = aa\n      wdec14Return.b = bb\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14\n      var n = nx > ny ? ny : nx\n      var p = 1\n      var p2\n\n      while (p <= n) p <<= 1\n\n      p >>= 1\n      p2 = p\n      p >>= 1\n\n      while (p >= 1) {\n        var py = 0\n        var ey = py + oy * (ny - p2)\n        var oy1 = oy * p\n        var oy2 = oy * p2\n        var ox1 = ox * p\n        var ox2 = ox * p2\n        var i00, i01, i10, i11\n\n        for (; py <= ey; py += oy2) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n            var p10 = px + oy1\n            var p11 = p10 + ox1\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec14(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec14(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec14(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec16(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec16(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec16(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1\n\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j])\n            else wdec16(buffer[px + j], buffer[p10 + j])\n\n            i00 = wdec14Return.a\n            buffer[p10 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        if (ny & p) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j])\n            else wdec16(buffer[px + j], buffer[p01 + j])\n\n            i00 = wdec14Return.a\n            buffer[p01 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        p2 = p\n        p >>= 1\n      }\n\n      return py\n    }\n\n    function hufDecode(\n      encodingTable,\n      decodingTable,\n      uInt8Array,\n      inDataView,\n      inOffset,\n      ni,\n      rlc,\n      no,\n      outBuffer,\n      outOffset,\n    ) {\n      var c = 0\n      var lc = 0\n      var outBufferEndOffset = no\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8)\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset)\n\n        c = getCharReturn.c\n        lc = getCharReturn.lc\n\n        while (lc >= HUF_DECBITS) {\n          var index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK\n          var pl = decodingTable[index]\n\n          if (pl.len) {\n            lc -= pl.len\n\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n            c = getCodeReturn.c\n            lc = getCodeReturn.lc\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues'\n            }\n\n            var j\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]])\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset)\n\n                c = getCharReturn.c\n                lc = getCharReturn.lc\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\n                  lc -= l\n\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset,\n                  )\n\n                  c = getCodeReturn.c\n                  lc = getCodeReturn.lc\n\n                  break\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues'\n            }\n          }\n        }\n      }\n\n      var i = (8 - ni) & 7\n\n      c >>= i\n      lc -= i\n\n      while (lc > 0) {\n        var pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK]\n\n        if (pl.len) {\n          lc -= pl.len\n\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n          c = getCodeReturn.c\n          lc = getCodeReturn.lc\n        } else {\n          throw 'hufDecode issues'\n        }\n      }\n\n      return true\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 }\n      var initialInOffset = inOffset.value\n\n      var im = parseUint32(inDataView, inOffset)\n      var iM = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      var nBits = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE'\n      }\n\n      var freq = new Array(HUF_ENCSIZE)\n      var hdec = new Array(HUF_DECSIZE)\n\n      hufClearDecTable(hdec)\n\n      var ni = nCompressed - (inOffset.value - initialInOffset)\n\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq)\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress'\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec)\n\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset)\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]]\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128\n        source[t] = d\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0\n      var t2 = Math.floor((source.length + 1) / 2)\n      var s = 0\n      var stop = source.length - 1\n\n      while (true) {\n        if (s > stop) break\n        out[s++] = source[t1++]\n\n        if (s > stop) break\n        out[s++] = source[t2++]\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength\n      var out = new Array()\n      var p = 0\n\n      var reader = new DataView(source)\n\n      while (size > 0) {\n        var l = reader.getInt8(p++)\n\n        if (l < 0) {\n          var count = -l\n          size -= count + 1\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++))\n          }\n        } else {\n          var count = l\n          size -= 2\n\n          var value = reader.getUint8(p++)\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value)\n          }\n        }\n      }\n\n      return out\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer)\n\n      var width = channelData[cscSet.idx[0]].width\n      var height = channelData[cscSet.idx[0]].height\n\n      var numComp = 3\n\n      var numFullBlocksX = Math.floor(width / 8.0)\n      var numBlocksX = Math.ceil(width / 8.0)\n      var numBlocksY = Math.ceil(height / 8.0)\n      var leftoverX = width - (numBlocksX - 1) * 8\n      var leftoverY = height - (numBlocksY - 1) * 8\n\n      var currAcComp = { value: 0 }\n      var currDcComp = new Array(numComp)\n      var dctData = new Array(numComp)\n      var halfZigBlock = new Array(numComp)\n      var rowBlock = new Array(numComp)\n      var rowOffsets = new Array(numComp)\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]]\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY\n        dctData[comp] = new Float32Array(64)\n        halfZigBlock[comp] = new Uint16Array(64)\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64)\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8\n\n        if (blocky == numBlocksY - 1) maxY = leftoverY\n\n        var maxX = 8\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0)\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp])\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp])\n            // decode float dct\n            dctInverse(dctData[comp])\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData)\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64)\n          }\n        } // blockx\n\n        let offset = 0\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y]\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8\n\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true)\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true)\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true)\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true)\n\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true)\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true)\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true)\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true)\n\n              offset += 8 * INT16_SIZE * type\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true)\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width)\n      var dataView = new DataView(outBuffer.buffer)\n\n      // convert channels back to float, if needed\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true\n        var type = channelData[cscSet.idx[comp]].type\n\n        if (channelData[comp].type != 2) continue\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y]\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true)\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true)\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue\n      var dctComp = 1\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value]\n\n        if (acValue == 0xff00) {\n          dctComp = 64\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff\n        } else {\n          halfZigBlock[dctComp] = acValue\n          dctComp++\n        }\n\n        currAcComp.value++\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0])\n      dst[1] = decodeFloat16(src[1])\n      dst[2] = decodeFloat16(src[5])\n      dst[3] = decodeFloat16(src[6])\n      dst[4] = decodeFloat16(src[14])\n      dst[5] = decodeFloat16(src[15])\n      dst[6] = decodeFloat16(src[27])\n      dst[7] = decodeFloat16(src[28])\n      dst[8] = decodeFloat16(src[2])\n      dst[9] = decodeFloat16(src[4])\n\n      dst[10] = decodeFloat16(src[7])\n      dst[11] = decodeFloat16(src[13])\n      dst[12] = decodeFloat16(src[16])\n      dst[13] = decodeFloat16(src[26])\n      dst[14] = decodeFloat16(src[29])\n      dst[15] = decodeFloat16(src[42])\n      dst[16] = decodeFloat16(src[3])\n      dst[17] = decodeFloat16(src[8])\n      dst[18] = decodeFloat16(src[12])\n      dst[19] = decodeFloat16(src[17])\n\n      dst[20] = decodeFloat16(src[25])\n      dst[21] = decodeFloat16(src[30])\n      dst[22] = decodeFloat16(src[41])\n      dst[23] = decodeFloat16(src[43])\n      dst[24] = decodeFloat16(src[9])\n      dst[25] = decodeFloat16(src[11])\n      dst[26] = decodeFloat16(src[18])\n      dst[27] = decodeFloat16(src[24])\n      dst[28] = decodeFloat16(src[31])\n      dst[29] = decodeFloat16(src[40])\n\n      dst[30] = decodeFloat16(src[44])\n      dst[31] = decodeFloat16(src[53])\n      dst[32] = decodeFloat16(src[10])\n      dst[33] = decodeFloat16(src[19])\n      dst[34] = decodeFloat16(src[23])\n      dst[35] = decodeFloat16(src[32])\n      dst[36] = decodeFloat16(src[39])\n      dst[37] = decodeFloat16(src[45])\n      dst[38] = decodeFloat16(src[52])\n      dst[39] = decodeFloat16(src[54])\n\n      dst[40] = decodeFloat16(src[20])\n      dst[41] = decodeFloat16(src[22])\n      dst[42] = decodeFloat16(src[33])\n      dst[43] = decodeFloat16(src[38])\n      dst[44] = decodeFloat16(src[46])\n      dst[45] = decodeFloat16(src[51])\n      dst[46] = decodeFloat16(src[55])\n      dst[47] = decodeFloat16(src[60])\n      dst[48] = decodeFloat16(src[21])\n      dst[49] = decodeFloat16(src[34])\n\n      dst[50] = decodeFloat16(src[37])\n      dst[51] = decodeFloat16(src[47])\n      dst[52] = decodeFloat16(src[50])\n      dst[53] = decodeFloat16(src[56])\n      dst[54] = decodeFloat16(src[59])\n      dst[55] = decodeFloat16(src[61])\n      dst[56] = decodeFloat16(src[35])\n      dst[57] = decodeFloat16(src[36])\n      dst[58] = decodeFloat16(src[48])\n      dst[59] = decodeFloat16(src[49])\n\n      dst[60] = decodeFloat16(src[57])\n      dst[61] = decodeFloat16(src[58])\n      dst[62] = decodeFloat16(src[62])\n      dst[63] = decodeFloat16(src[63])\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0)\n      const b = 0.5 * Math.cos(3.14159 / 16.0)\n      const c = 0.5 * Math.cos(3.14159 / 8.0)\n      const d = 0.5 * Math.cos((3.0 * 3.14159) / 16.0)\n      const e = 0.5 * Math.cos((5.0 * 3.14159) / 16.0)\n      const f = 0.5 * Math.cos((3.0 * 3.14159) / 8.0)\n      const g = 0.5 * Math.cos((7.0 * 3.14159) / 16.0)\n\n      var alpha = new Array(4)\n      var beta = new Array(4)\n      var theta = new Array(4)\n      var gamma = new Array(4)\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8\n\n        alpha[0] = c * data[rowPtr + 2]\n        alpha[1] = f * data[rowPtr + 2]\n        alpha[2] = c * data[rowPtr + 6]\n        alpha[3] = f * data[rowPtr + 6]\n\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7]\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7]\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7]\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7]\n\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4])\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4])\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[rowPtr + 0] = gamma[0] + beta[0]\n        data[rowPtr + 1] = gamma[1] + beta[1]\n        data[rowPtr + 2] = gamma[2] + beta[2]\n        data[rowPtr + 3] = gamma[3] + beta[3]\n\n        data[rowPtr + 4] = gamma[3] - beta[3]\n        data[rowPtr + 5] = gamma[2] - beta[2]\n        data[rowPtr + 6] = gamma[1] - beta[1]\n        data[rowPtr + 7] = gamma[0] - beta[0]\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column]\n        alpha[1] = f * data[16 + column]\n        alpha[2] = c * data[48 + column]\n        alpha[3] = f * data[48 + column]\n\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column]\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column]\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column]\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column]\n\n        theta[0] = a * (data[column] + data[32 + column])\n        theta[3] = a * (data[column] - data[32 + column])\n\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[0 + column] = gamma[0] + beta[0]\n        data[8 + column] = gamma[1] + beta[1]\n        data[16 + column] = gamma[2] + beta[2]\n        data[24 + column] = gamma[3] + beta[3]\n\n        data[32 + column] = gamma[3] - beta[3]\n        data[40 + column] = gamma[2] - beta[2]\n        data[48 + column] = gamma[1] - beta[1]\n        data[56 + column] = gamma[0] - beta[0]\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i]\n        var cb = data[1][i]\n        var cr = data[2][i]\n\n        data[0][i] = y + 1.5747 * cr\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr\n        data[2][i] = y + 1.8556 * cb\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]))\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2)\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0)\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size)\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size)\n\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed))\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type))\n      var bitmap = new Uint8Array(BITMAP_SIZE)\n\n      // Setup channel info\n      var outBufferEnd = 0\n      var pizChannelData = new Array(info.channels)\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {}\n        pizChannelData[i]['start'] = outBufferEnd\n        pizChannelData[i]['end'] = pizChannelData[i]['start']\n        pizChannelData[i]['nx'] = info.width\n        pizChannelData[i]['ny'] = info.lines\n        pizChannelData[i]['size'] = info.type\n\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size\n      }\n\n      // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset)\n      var maxNonZero = parseUint16(inDataView, inOffset)\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset)\n        }\n      }\n\n      // Reverse LUT\n      var lut = new Uint16Array(USHORT_RANGE)\n      var maxValue = reverseLutFromBitmap(bitmap, lut)\n\n      var length = parseUint32(inDataView, inOffset)\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd)\n\n      // Wavelet decoding\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i]\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd)\n\n      // Rearrange the pixel data into the format expected by the caller.\n      var tmpOffset = 0\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength)\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c]\n\n          var n = cd.nx * cd.size\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE)\n\n          tmpBuffer.set(cp, tmpOffset)\n          tmpOffset += n * INT16_SIZE\n          cd.end += n\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n\n      const sz = info.lines * info.channels * info.width\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz)\n\n      let tmpBufferEnd = 0\n      let writePtr = 0\n      const ptr = new Array(4)\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              tmpBufferEnd = ptr[1] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++]\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n\n            case 2:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              ptr[2] = ptr[1] + info.width\n              tmpBufferEnd = ptr[2] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8)\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE))\n\n      // Read compression header information\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset),\n      }\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'\n      }\n\n      // Read channel ruleset information\n      var channelRules = new Array()\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset)\n        var value = parseUint8(inDataView, inOffset)\n        var compression = (value >> 2) & 3\n        var csc = (value >> 4) - 1\n        var index = new Int8Array([csc])[0]\n        var type = parseUint8(inDataView, inOffset)\n\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression,\n        })\n\n        ruleSize -= name.length + 3\n      }\n\n      // Classify channels\n      var channels = EXRHeader.channels\n      var channelData = new Array(info.channels)\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = (channelData[i] = {})\n        var channel = channels[i]\n\n        cd.name = channel.name\n        cd.compression = UNKNOWN\n        cd.decoded = false\n        cd.type = channel.pixelType\n        cd.pLinear = channel.pLinear\n        cd.width = info.width\n        cd.height = info.lines\n      }\n\n      var cscSet = {\n        idx: new Array(3),\n      }\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset]\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i]\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset\n            }\n\n            cd.offset = offset\n          }\n        }\n      }\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount)\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount,\n            )\n            break\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount)\n            var data = unzlibSync(compressed)\n            var acBuffer = new Uint16Array(data.buffer)\n            inOffset.value += dwaHeader.totalAcUncompressedCount\n            break\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize,\n        }\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer)\n        inOffset.value += dwaHeader.dcCompressedSize\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize)\n        var data = unzlibSync(compressed)\n        var rleBuffer = decodeRunLength(data.buffer)\n\n        inOffset.value += dwaHeader.rleCompressedSize\n      }\n\n      // Prepare outbuffer data offset\n      var outBufferEnd = 0\n      var rowOffsets = new Array(channelData.length)\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array()\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd)\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer)\n\n      // Decode other channels\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i]\n\n        if (cd.decoded) continue\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0\n            var rleOffset = 0\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row]\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height]\n                }\n\n                rleOffset++\n              }\n\n              row++\n            }\n\n            break\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression'\n        }\n      }\n\n      return new DataView(outBuffer.buffer)\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer)\n      var endOffset = 0\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset))\n\n      offset.value = offset.value + endOffset + 1\n\n      return stringValue\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size))\n\n      offset.value = offset.value + size\n\n      return stringValue\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Int32\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Uint32\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value]\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value)\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true))\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32)\n      }\n\n      offset.value += ULONG_SIZE\n\n      return int\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true)\n\n      offset.value += FLOAT32_SIZE\n\n      return float\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset))\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff\n\n      return (\n        (binary >> 15 ? -1 : 1) *\n        (exponent\n          ? exponent === 0x1f\n            ? fraction\n              ? NaN\n              : Infinity\n            : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n          : 6.103515625e-5 * (fraction / 0x400))\n      )\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true)\n\n      offset.value += INT16_SIZE\n\n      return Uint16\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset))\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value\n      var channels = []\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset)\n        var pixelType = parseInt32(dataView, offset)\n        var pLinear = parseUint8(dataView, offset)\n        offset.value += 3 // reserved, three chars\n        var xSampling = parseInt32(dataView, offset)\n        var ySampling = parseInt32(dataView, offset)\n\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling,\n        })\n      }\n\n      offset.value += 1\n\n      return channels\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset)\n      var redY = parseFloat32(dataView, offset)\n      var greenX = parseFloat32(dataView, offset)\n      var greenY = parseFloat32(dataView, offset)\n      var blueX = parseFloat32(dataView, offset)\n      var blueY = parseFloat32(dataView, offset)\n      var whiteX = parseFloat32(dataView, offset)\n      var whiteY = parseFloat32(dataView, offset)\n\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY,\n      }\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = [\n        'NO_COMPRESSION',\n        'RLE_COMPRESSION',\n        'ZIPS_COMPRESSION',\n        'ZIP_COMPRESSION',\n        'PIZ_COMPRESSION',\n        'PXR24_COMPRESSION',\n        'B44_COMPRESSION',\n        'B44A_COMPRESSION',\n        'DWAA_COMPRESSION',\n        'DWAB_COMPRESSION',\n      ]\n\n      var compression = parseUint8(dataView, offset)\n\n      return compressionCodes[compression]\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset)\n      var yMin = parseUint32(dataView, offset)\n      var xMax = parseUint32(dataView, offset)\n      var yMax = parseUint32(dataView, offset)\n\n      return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax }\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y']\n\n      var lineOrder = parseUint8(dataView, offset)\n\n      return lineOrders[lineOrder]\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n      var z = parseFloat32(dataView, offset)\n\n      return [x, y, z]\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size)\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size)\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset)\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset)\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset)\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset)\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset)\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset)\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset)\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset)\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset)\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset)\n      } else if (type === 'preview') {\n        offset.value += size\n        return 'skipped'\n      } else {\n        offset.value += size\n        return undefined\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {}\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\"\n      }\n\n      EXRHeader.version = dataView.getUint8(4)\n\n      const spec = dataView.getUint8(5) // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16),\n      }\n\n      // start of header\n\n      offset.value = 8 // start at 8 - after pre-amble\n\n      var keepReading = true\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset)\n\n        if (attributeName == 0) {\n          keepReading = false\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset)\n          var attributeSize = parseUint32(dataView, offset)\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize)\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`)\n          } else {\n            EXRHeader[attributeName] = attributeValue\n          }\n        }\n      }\n\n      if ((spec & ~0x04) != 0) {\n        // unsupported tiled, deep-image, multi-part\n        console.error('EXRHeader:', EXRHeader)\n        throw 'THREE.EXRLoader: provided file is currently unsupported.'\n      }\n\n      return EXRHeader\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? 'colorSpace' : 'encoding']: null,\n      }\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRAW\n          break\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRLE\n          break\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressPIZ\n          break\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressPXR\n          break\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported'\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.'\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset) // scanlineOffset\n\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size)\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size)\n\n          break\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size)\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size) // Uint16Array holds half float data, 0x3C00 is 1\n\n          break\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType)\n          break\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels\n\n      if (EXRDecoder.outputChannels == 4) EXRDecoder.format = RGBAFormat\n      else EXRDecoder.format = RedFormat\n\n      if (hasColorSpace) EXRDecoder.colorSpace = 'srgb-linear'\n      else EXRDecoder.encoding = 3000 // LinearEncoding\n\n      return EXRDecoder\n    }\n\n    // start parsing file [START]\n\n    const bufferDataView = new DataView(buffer)\n    const uInt8Array = new Uint8Array(buffer)\n    const offset = { value: 0 }\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset)\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type)\n\n    const tmpOffset = { value: 0 }\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 }\n\n    for (\n      let scanlineBlockIdx = 0;\n      scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize;\n      scanlineBlockIdx++\n    ) {\n      const line = parseUint32(bufferDataView, offset) // line_no\n      EXRDecoder.size = parseUint32(bufferDataView, offset) // data_len\n      EXRDecoder.lines =\n        line + EXRDecoder.scanlineBlockSize > EXRDecoder.height\n          ? EXRDecoder.height - line\n          : EXRDecoder.scanlineBlockSize\n\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder)\n\n      offset.value += EXRDecoder.size\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize\n        if (true_y >= EXRDecoder.height) break\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name]\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value =\n              (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) *\n              EXRDecoder.inputSize\n            const outIndex =\n              (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) +\n              x * EXRDecoder.outputChannels +\n              cOff\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset)\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? 'colorSpace' : 'encoding']: EXRDecoder[hasColorSpace ? 'colorSpace' : 'encoding'],\n      type: this.type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace\n      else texture.encoding = texData.encoding\n      texture.minFilter = LinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.flipY = false\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { EXRLoader }\n","/**\n * @monogrid/gainmap-js v3.1.0\n * With , by MONOGRID <rnd@monogrid.com>\n */\n\nimport { RGBAFormat, LinearFilter, ClampToEdgeWrapping, Scene, OrthographicCamera, HalfFloatType, FloatType, Mesh, PlaneGeometry, WebGLRenderTarget, UVMapping, WebGLRenderer, DataTexture, LinearSRGBColorSpace, ShaderMaterial, Texture, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType, MeshBasicMaterial } from 'three';\n\nconst getBufferForType = (type, width, height) => {\n    let out;\n    switch (type) {\n        case UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error('Unsupported data type');\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n    if (_canReadPixelsResult !== undefined)\n        return _canReadPixelsResult;\n    const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({ color: 0xffffff }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */\n        this.render = () => {\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            }\n            catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type, // set in class property\n            colorSpace: this._colorSpace, // set in class property\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : LinearFilter,\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : LinearFilter,\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : ClampToEdgeWrapping,\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        }\n        else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new Scene();\n        this._camera = new OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch (this._type) {\n                case HalfFloatType:\n                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);\n                this._type = alternativeType;\n            }\n            else {\n                this._supportsReadPixels = false;\n                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n            }\n        }\n        this._quad = new Mesh(new PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */\n    static instantiateRenderer() {\n        const renderer = new WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */\n    toArray() {\n        if (!this._supportsReadPixels)\n            throw new Error('Can\\'t read pixels in this browser');\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @param options options\n     * @returns\n     */\n    toDataTexture(options) {\n        const returnValue = new DataTexture(\n        // fixed values\n        this.toArray(), this.width, this.height, RGBAFormat, this._type, \n        // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, \n        // fixed value\n        LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */\n    disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */\n    dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach(v => {\n                if (v.value instanceof Texture)\n                    v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach(value => {\n            if (value instanceof Texture)\n                value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */\n    get width() { return this._width; }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */\n    get height() { return this._height; }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */\n    get renderer() { return this._renderer; }\n    /**\n     * The `WebGLRenderTarget` used.\n     */\n    get renderTarget() { return this._renderTarget; }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n        // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */\n    get material() { return this._material; }\n    /**\n     *\n     */\n    get type() { return this._type; }\n    get colorSpace() { return this._colorSpace; }\n}\n\nexport { QuadRenderer as Q };\n","/**\n * @monogrid/gainmap-js v3.1.0\n * With , by MONOGRID <rnd@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-DuOPRGA4.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== SRGBColorSpace) {\n        console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n        sdr.colorSpace = SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n        console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n        gainMap.colorSpace = LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new QuadRenderer({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: HalfFloatType,\n        colorSpace: LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getXMLValue = (xml, tag, defaultValue) => {\n    // Check for attribute format first: tag=\"value\"\n    const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, 'i').exec(xml);\n    if (attributeMatch)\n        return attributeMatch[1];\n    // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n    const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, 'i').exec(xml);\n    if (tagMatch) {\n        // Check if it contains rdf:li elements\n        const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n        if (liValues && liValues.length === 3) {\n            return liValues.map(v => v.replace(/<\\/?rdf:li>/g, ''));\n        }\n        return tagMatch[1].trim();\n    }\n    if (defaultValue !== undefined)\n        return defaultValue;\n    throw new Error(`Can't find ${tag} in gainmap metadata`);\n};\nconst extractXMP = (input) => {\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');\n            const gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');\n            const offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');\n            // These are always attributes, so we can use a simpler regex\n            const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n            const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';\n            const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n            if (!hdrCapacityMaxMatch)\n                throw new Error('Incomplete gainmap metadata');\n            const hdrCapacityMax = hdrCapacityMaxMatch[1];\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n            // Continue searching for another xmpmeta block if this one fails\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops `));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\nclass LoaderBase extends Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */\n    constructor(renderer, manager) {\n        super(manager);\n        if (renderer)\n            this._renderer = renderer;\n        this._internalLoadingManager = new LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */\n    prepareQuadRenderer() {\n        if (!this._renderer)\n            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new Texture(),\n            sdr: new Texture()\n        });\n        return new QuadRenderer({\n            width: 16,\n            height: 16,\n            type: HalfFloatType,\n            colorSpace: LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };\n","const presetsObj = {\n  apartment: 'lebombo_1k.hdr',\n  city: 'potsdamer_platz_1k.hdr',\n  dawn: 'kiara_1_dawn_1k.hdr',\n  forest: 'forest_slope_1k.hdr',\n  lobby: 'st_fagans_interior_1k.hdr',\n  night: 'dikhololo_night_1k.hdr',\n  park: 'rooitou_park_1k.hdr',\n  studio: 'studio_small_03_1k.hdr',\n  sunset: 'venice_sunset_1k.hdr',\n  warehouse: 'empty_warehouse_01_1k.hdr'\n};\n\nexport { presetsObj };\n","import { useThree, useLoader } from '@react-three/fiber';\nimport { CubeReflectionMapping, EquirectangularReflectionMapping, CubeTextureLoader } from 'three';\nimport { RGBELoader, EXRLoader } from 'three-stdlib';\nimport { HDRJPGLoader, GainMapLoader } from '@monogrid/gainmap-js';\nimport { presetsObj } from '../helpers/environment-assets.js';\nimport { useLayoutEffect } from 'react';\n\nconst CUBEMAP_ROOT = 'https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/';\nconst isArray = arr => Array.isArray(arr);\nconst defaultFiles = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'];\nfunction useEnvironment({\n  files = defaultFiles,\n  path = '',\n  preset = undefined,\n  colorSpace = undefined,\n  extensions\n} = {}) {\n  if (preset) {\n    validatePreset(preset);\n    files = presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n\n  // Everything else\n  const multiFile = isArray(files);\n  const {\n    extension,\n    isCubemap\n  } = getExtension(files);\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  const gl = useThree(state => state.gl);\n  useLayoutEffect(() => {\n    // Only required for gainmap\n    if (extension !== 'webp' && extension !== 'jpg' && extension !== 'jpeg') return;\n    function clearGainmapTexture() {\n      useLoader.clear(loader, multiFile ? [files] : files);\n    }\n    gl.domElement.addEventListener('webglcontextlost', clearGainmapTexture, {\n      once: true\n    });\n  }, [files, gl.domElement]);\n  const loaderResult = useLoader(loader, multiFile ? [files] : files, loader => {\n    // Gainmap requires a renderer\n    if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n      // @ts-expect-error\n      loader.setRenderer(gl);\n    }\n    loader.setPath == null || loader.setPath(path);\n    // @ts-expect-error\n    if (extensions) extensions(loader);\n  });\n  let texture = multiFile ?\n  // @ts-ignore\n  loaderResult[0] : loaderResult;\n  if (extension === 'jpg' || extension === 'jpeg' || extension === 'webp') {\n    var _renderTarget;\n    texture = (_renderTarget = texture.renderTarget) == null ? void 0 : _renderTarget.texture;\n  }\n  texture.mapping = isCubemap ? CubeReflectionMapping : EquirectangularReflectionMapping;\n  texture.colorSpace = colorSpace !== null && colorSpace !== void 0 ? colorSpace : isCubemap ? 'srgb' : 'srgb-linear';\n  return texture;\n}\nconst preloadDefaultOptions = {\n  files: defaultFiles,\n  path: '',\n  preset: undefined,\n  extensions: undefined\n};\nuseEnvironment.preload = preloadOptions => {\n  const options = {\n    ...preloadDefaultOptions,\n    ...preloadOptions\n  };\n  let {\n    files,\n    path = ''\n  } = options;\n  const {\n    preset,\n    extensions\n  } = options;\n  if (preset) {\n    validatePreset(preset);\n    files = presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n  const {\n    extension\n  } = getExtension(files);\n  if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n    throw new Error('useEnvironment: Preloading gainmaps is not supported');\n  }\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  useLoader.preload(loader, isArray(files) ? [files] : files, loader => {\n    loader.setPath == null || loader.setPath(path);\n    // @ts-expect-error\n    if (extensions) extensions(loader);\n  });\n};\nconst clearDefaultOptins = {\n  files: defaultFiles,\n  preset: undefined\n};\nuseEnvironment.clear = clearOptions => {\n  const options = {\n    ...clearDefaultOptins,\n    ...clearOptions\n  };\n  let {\n    files\n  } = options;\n  const {\n    preset\n  } = options;\n  if (preset) {\n    validatePreset(preset);\n    files = presetsObj[preset];\n  }\n  const {\n    extension\n  } = getExtension(files);\n  const loader = getLoader(extension);\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  useLoader.clear(loader, isArray(files) ? [files] : files);\n};\nfunction validatePreset(preset) {\n  if (!(preset in presetsObj)) throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));\n}\nfunction getExtension(files) {\n  var _firstEntry$split$pop;\n  const isCubemap = isArray(files) && files.length === 6;\n  const isGainmap = isArray(files) && files.length === 3 && files.some(file => file.endsWith('json'));\n  const firstEntry = isArray(files) ? files[0] : files;\n\n  // Everything else\n  const extension = isCubemap ? 'cube' : isGainmap ? 'webp' : firstEntry.startsWith('data:application/exr') ? 'exr' : firstEntry.startsWith('data:application/hdr') ? 'hdr' : firstEntry.startsWith('data:image/jpeg') ? 'jpg' : (_firstEntry$split$pop = firstEntry.split('.').pop()) == null || (_firstEntry$split$pop = _firstEntry$split$pop.split('?')) == null || (_firstEntry$split$pop = _firstEntry$split$pop.shift()) == null ? void 0 : _firstEntry$split$pop.toLowerCase();\n  return {\n    extension,\n    isCubemap,\n    isGainmap\n  };\n}\nfunction getLoader(extension) {\n  const loader = extension === 'cube' ? CubeTextureLoader : extension === 'hdr' ? RGBELoader : extension === 'exr' ? EXRLoader : extension === 'jpg' || extension === 'jpeg' ? HDRJPGLoader : extension === 'webp' ? GainMapLoader : null;\n  return loader;\n}\n\nexport { useEnvironment };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useThree, useFrame, createPortal, applyProps, extend } from '@react-three/fiber';\nimport { Scene, WebGLCubeRenderTarget, HalfFloatType } from 'three';\nimport { GroundProjectedEnv } from 'three-stdlib';\nimport { useEnvironment } from './useEnvironment.js';\n\nconst isRef = obj => obj.current && obj.current.isScene;\nconst resolveScene = scene => isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, sceneProps = {}) {\n  var _target$backgroundRot, _target$backgroundRot2, _target$environmentRo, _target$environmentRo2;\n  // defaults\n  sceneProps = {\n    backgroundBlurriness: 0,\n    backgroundIntensity: 1,\n    backgroundRotation: [0, 0, 0],\n    environmentIntensity: 1,\n    environmentRotation: [0, 0, 0],\n    ...sceneProps\n  };\n  const target = resolveScene(scene || defaultScene);\n  const oldbg = target.background;\n  const oldenv = target.environment;\n  const oldSceneProps = {\n    // @ts-ignore\n    backgroundBlurriness: target.backgroundBlurriness,\n    // @ts-ignore\n    backgroundIntensity: target.backgroundIntensity,\n    // @ts-ignore\n    backgroundRotation: (_target$backgroundRot = (_target$backgroundRot2 = target.backgroundRotation) == null || _target$backgroundRot2.clone == null ? void 0 : _target$backgroundRot2.clone()) !== null && _target$backgroundRot !== void 0 ? _target$backgroundRot : [0, 0, 0],\n    // @ts-ignore\n    environmentIntensity: target.environmentIntensity,\n    // @ts-ignore\n    environmentRotation: (_target$environmentRo = (_target$environmentRo2 = target.environmentRotation) == null || _target$environmentRo2.clone == null ? void 0 : _target$environmentRo2.clone()) !== null && _target$environmentRo !== void 0 ? _target$environmentRo : [0, 0, 0]\n  };\n  if (background !== 'only') target.environment = texture;\n  if (background) target.background = texture;\n  applyProps(target, sceneProps);\n  return () => {\n    if (background !== 'only') target.environment = oldenv;\n    if (background) target.background = oldbg;\n    applyProps(target, oldSceneProps);\n  };\n}\nfunction EnvironmentMap({\n  scene,\n  background = false,\n  map,\n  ...config\n}) {\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    if (map) return setEnvProps(background, scene, defaultScene, map, config);\n  });\n  return null;\n}\nfunction EnvironmentCube({\n  background = false,\n  scene,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  ...rest\n}) {\n  const texture = useEnvironment(rest);\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    return setEnvProps(background, scene, defaultScene, texture, {\n      backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  });\n  React.useEffect(() => {\n    return () => {\n      texture.dispose();\n    };\n  }, [texture]);\n  return null;\n}\nfunction EnvironmentPortal({\n  children,\n  near = 0.1,\n  far = 1000,\n  resolution = 256,\n  frames = 1,\n  map,\n  background = false,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  scene,\n  files,\n  path,\n  preset = undefined,\n  extensions\n}) {\n  const gl = useThree(state => state.gl);\n  const defaultScene = useThree(state => state.scene);\n  const camera = React.useRef(null);\n  const [virtualScene] = React.useState(() => new Scene());\n  const fbo = React.useMemo(() => {\n    const fbo = new WebGLCubeRenderTarget(resolution);\n    fbo.texture.type = HalfFloatType;\n    return fbo;\n  }, [resolution]);\n  React.useEffect(() => {\n    return () => {\n      fbo.dispose();\n    };\n  }, [fbo]);\n  React.useLayoutEffect(() => {\n    if (frames === 1) {\n      const autoClear = gl.autoClear;\n      gl.autoClear = true;\n      camera.current.update(gl, virtualScene);\n      gl.autoClear = autoClear;\n    }\n    return setEnvProps(background, scene, defaultScene, fbo.texture, {\n      backgroundBlurriness: blur !== null && blur !== void 0 ? blur : backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  }, [children, virtualScene, fbo.texture, scene, defaultScene, background, frames, gl]);\n  let count = 1;\n  useFrame(() => {\n    if (frames === Infinity || count < frames) {\n      const autoClear = gl.autoClear;\n      gl.autoClear = true;\n      camera.current.update(gl, virtualScene);\n      gl.autoClear = autoClear;\n      count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal(/*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo]\n  }), files || preset ? /*#__PURE__*/React.createElement(EnvironmentCube, {\n    background: true,\n    files: files,\n    preset: preset,\n    path: path,\n    extensions: extensions\n  }) : map ? /*#__PURE__*/React.createElement(EnvironmentMap, {\n    background: true,\n    map: map,\n    extensions: extensions\n  }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n  var _props$ground, _props$ground2, _scale, _props$ground3;\n  const textureDefault = useEnvironment(props);\n  const texture = props.map || textureDefault;\n  React.useMemo(() => extend({\n    GroundProjectedEnvImpl: GroundProjectedEnv\n  }), []);\n  React.useEffect(() => {\n    return () => {\n      textureDefault.dispose();\n    };\n  }, [textureDefault]);\n  const args = React.useMemo(() => [texture], [texture]);\n  const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n  const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n  const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(EnvironmentMap, _extends({}, props, {\n    map: texture\n  })), /*#__PURE__*/React.createElement(\"groundProjectedEnvImpl\", {\n    args: args,\n    scale: scale,\n    height: height,\n    radius: radius\n  }));\n}\nfunction Environment(props) {\n  return props.ground ? /*#__PURE__*/React.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/React.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/React.createElement(EnvironmentPortal, props) : /*#__PURE__*/React.createElement(EnvironmentCube, props);\n}\n\nexport { Environment, EnvironmentCube, EnvironmentMap, EnvironmentPortal };\n","import { BufferAttribute, BufferGeometry, FileLoader, Loader } from 'three'\n\nconst _taskCache = new WeakMap()\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.decoderPath = ''\n    this.decoderConfig = {}\n    this.decoderBinary = null\n    this.decoderPending = null\n\n    this.workerLimit = 4\n    this.workerPool = []\n    this.workerNextTaskID = 1\n    this.workerSourceURL = ''\n\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD',\n    }\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array',\n    }\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path\n\n    return this\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config\n\n    return this\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit\n\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (buffer) => {\n        const taskConfig = {\n          attributeIDs: this.defaultAttributeIDs,\n          attributeTypes: this.defaultAttributeTypes,\n          useUniqueIDs: false,\n        }\n\n        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)\n      },\n      onProgress,\n      onError,\n    )\n  }\n\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs,\n    }\n\n    this.decodeGeometry(buffer, taskConfig).then(callback)\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute]\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name\n      }\n    }\n\n    //\n\n    const taskKey = JSON.stringify(taskConfig)\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer)\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +\n            'settings. Buffer has already been transferred.',\n        )\n      }\n    }\n\n    //\n\n    let worker\n    const taskID = this.workerNextTaskID++\n    const taskCost = buffer.byteLength\n\n    // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n    const geometryPending = this._getWorker(taskID, taskCost)\n      .then((_worker) => {\n        worker = _worker\n\n        return new Promise((resolve, reject) => {\n          worker._callbacks[taskID] = { resolve, reject }\n\n          worker.postMessage({ type: 'decode', id: taskID, taskConfig, buffer }, [buffer])\n\n          // this.debug();\n        })\n      })\n      .then((message) => this._createGeometry(message.geometry))\n\n    // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n    geometryPending\n      .catch(() => true)\n      .then(() => {\n        if (worker && taskID) {\n          this._releaseTask(worker, taskID)\n\n          // this.debug();\n        }\n      })\n\n    // Cache the task result.\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending,\n    })\n\n    return geometryPending\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry()\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i]\n      const name = attribute.name\n      const array = attribute.array\n      const itemSize = attribute.itemSize\n\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize))\n    }\n\n    return geometry\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager)\n    loader.setPath(this.decoderPath)\n    loader.setResponseType(responseType)\n    loader.setWithCredentials(this.withCredentials)\n\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject)\n    })\n  }\n\n  preload() {\n    this._initDecoder()\n\n    return this\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending\n\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'\n    const librariesPending = []\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then((libraries) => {\n      const jsContent = libraries[0]\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1]\n      }\n\n      const fn = DRACOWorker.toString()\n\n      const body = [\n        '/* draco decoder */',\n        jsContent,\n        '',\n        '/* worker */',\n        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),\n      ].join('\\n')\n\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]))\n    })\n\n    return this.decoderPending\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL)\n\n        worker._callbacks = {}\n        worker._taskCosts = {}\n        worker._taskLoad = 0\n\n        worker.postMessage({ type: 'init', decoderConfig: this.decoderConfig })\n\n        worker.onmessage = function (e) {\n          const message = e.data\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message)\n              break\n\n            case 'error':\n              worker._callbacks[message.id].reject(message)\n              break\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"')\n          }\n        }\n\n        this.workerPool.push(worker)\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1\n        })\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1]\n      worker._taskCosts[taskID] = taskCost\n      worker._taskLoad += taskCost\n      return worker\n    })\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID]\n    delete worker._callbacks[taskID]\n    delete worker._taskCosts[taskID]\n  }\n\n  debug() {\n    console.log(\n      'Task load: ',\n      this.workerPool.map((worker) => worker._taskLoad),\n    )\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate()\n    }\n\n    this.workerPool.length = 0\n\n    return this\n  }\n}\n\n/* WEB WORKER */\n\nfunction DRACOWorker() {\n  let decoderConfig\n  let decoderPending\n\n  onmessage = function (e) {\n    const message = e.data\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({ draco: draco })\n          }\n\n          DracoDecoderModule(decoderConfig)\n        })\n        break\n\n      case 'decode':\n        const buffer = message.buffer\n        const taskConfig = message.taskConfig\n        decoderPending.then((module) => {\n          const draco = module.draco\n          const decoder = new draco.Decoder()\n          const decoderBuffer = new draco.DecoderBuffer()\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig)\n\n            const buffers = geometry.attributes.map((attr) => attr.array.buffer)\n\n            if (geometry.index) buffers.push(geometry.index.array.buffer)\n\n            self.postMessage({ type: 'decode', id: message.id, geometry }, buffers)\n          } catch (error) {\n            console.error(error)\n\n            self.postMessage({ type: 'error', id: message.id, error: error.message })\n          } finally {\n            draco.destroy(decoderBuffer)\n            draco.destroy(decoder)\n          }\n        })\n        break\n    }\n  }\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs\n    const attributeTypes = taskConfig.attributeTypes\n\n    let dracoGeometry\n    let decodingStatus\n\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh()\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud()\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry)\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())\n    }\n\n    const geometry = { index: null, attributes: [] }\n\n    // Gather all vertex attributes.\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]]\n\n      let attribute\n      let attributeID\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName]\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]])\n\n        if (attributeID === -1) continue\n\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID)\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute))\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry)\n    }\n\n    draco.destroy(dracoGeometry)\n\n    return geometry\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces()\n    const numIndices = numFaces * 3\n    const byteLength = numIndices * 4\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()\n    draco._free(ptr)\n\n    return { array: index, itemSize: 1 }\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components()\n    const numPoints = dracoGeometry.num_points()\n    const numValues = numPoints * numComponents\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT\n    const dataType = getDracoDataType(draco, attributeType)\n\n    const ptr = draco._malloc(byteLength)\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr)\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice()\n    draco._free(ptr)\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents,\n    }\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32\n      case Int8Array:\n        return draco.DT_INT8\n      case Int16Array:\n        return draco.DT_INT16\n      case Int32Array:\n        return draco.DT_INT32\n      case Uint8Array:\n        return draco.DT_UINT8\n      case Uint16Array:\n        return draco.DT_UINT16\n      case Uint32Array:\n        return draco.DT_UINT32\n    }\n  }\n}\n\nexport { DRACOLoader }\n","// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2020, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n\ntype API = {\n  ready: Promise<void>\n  supported: boolean\n  decodeVertexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array, filter?: string) => void\n  decodeIndexBuffer: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeIndexSequence: (target: Uint8Array, count: number, size: number, source: Uint8Array) => void\n  decodeGltfBuffer: (\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    mode: string,\n    filter?: string,\n  ) => void\n}\n\nlet generated: API\n\nconst MeshoptDecoder = () => {\n  if (generated) return generated\n\n  // Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n  // Built from meshoptimizer 0.14\n  const wasm_base =\n    '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'\n  const wasm_simd =\n    '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'\n\n  // Uses bulk-memory and simd extensions\n  const detector = new Uint8Array([\n    0,\n    97,\n    115,\n    109,\n    1,\n    0,\n    0,\n    0,\n    1,\n    4,\n    1,\n    96,\n    0,\n    0,\n    3,\n    3,\n    2,\n    0,\n    0,\n    5,\n    3,\n    1,\n    0,\n    1,\n    12,\n    1,\n    0,\n    10,\n    22,\n    2,\n    12,\n    0,\n    65,\n    0,\n    65,\n    0,\n    65,\n    0,\n    252,\n    10,\n    0,\n    0,\n    11,\n    7,\n    0,\n    65,\n    0,\n    253,\n    15,\n    26,\n    11,\n  ])\n\n  // Used to unpack wasm\n  const wasmpack = new Uint8Array([\n    32,\n    0,\n    65,\n    253,\n    3,\n    1,\n    2,\n    34,\n    4,\n    106,\n    6,\n    5,\n    11,\n    8,\n    7,\n    20,\n    13,\n    33,\n    12,\n    16,\n    128,\n    9,\n    116,\n    64,\n    19,\n    113,\n    127,\n    15,\n    10,\n    21,\n    22,\n    14,\n    255,\n    66,\n    24,\n    54,\n    136,\n    107,\n    18,\n    23,\n    192,\n    26,\n    114,\n    118,\n    132,\n    17,\n    77,\n    101,\n    130,\n    144,\n    27,\n    87,\n    131,\n    44,\n    45,\n    74,\n    156,\n    154,\n    70,\n    167,\n  ])\n\n  if (typeof WebAssembly !== 'object') {\n    // This module requires WebAssembly to function\n    return {\n      supported: false,\n    }\n  }\n\n  let wasm = wasm_base\n\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd\n  }\n\n  let instance: any // WebAssembly.Instance\n\n  const promise = WebAssembly.instantiate(unpack(wasm), {}).then((result) => {\n    instance = result.instance\n    instance.exports.__wasm_call_ctors()\n  })\n\n  function unpack(data: string) {\n    const result = new Uint8Array(data.length)\n    for (let i = 0; i < data.length; ++i) {\n      const ch = data.charCodeAt(i)\n      result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62\n    }\n    let write = 0\n    for (let i = 0; i < data.length; ++i) {\n      result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i]\n    }\n    return result.buffer.slice(0, write)\n  }\n\n  function decode(\n    fun: Function,\n    target: Uint8Array,\n    count: number,\n    size: number,\n    source: Uint8Array,\n    filter?: Function,\n  ) {\n    const sbrk = instance.exports.sbrk\n    const count4 = (count + 3) & ~3 // pad for SIMD filter\n    const tp = sbrk(count4 * size)\n    const sp = sbrk(source.length)\n    const heap = new Uint8Array(instance.exports.memory.buffer)\n    heap.set(source, sp)\n    const res = fun(tp, count, size, sp, source.length)\n    if (res === 0 && filter) {\n      filter(tp, count4, size)\n    }\n    target.set(heap.subarray(tp, tp + count * size))\n    sbrk(tp - sbrk(0))\n    if (res !== 0) {\n      throw new Error(`Malformed buffer data: ${res}`)\n    }\n  }\n\n  const filters = {\n    // legacy index-based enums for glTF\n    0: '',\n    1: 'meshopt_decodeFilterOct',\n    2: 'meshopt_decodeFilterQuat',\n    3: 'meshopt_decodeFilterExp',\n    // string-based enums for glTF\n    NONE: '',\n    OCTAHEDRAL: 'meshopt_decodeFilterOct',\n    QUATERNION: 'meshopt_decodeFilterQuat',\n    EXPONENTIAL: 'meshopt_decodeFilterExp',\n  }\n\n  const decoders = {\n    // legacy index-based enums for glTF\n    0: 'meshopt_decodeVertexBuffer',\n    1: 'meshopt_decodeIndexBuffer',\n    2: 'meshopt_decodeIndexSequence',\n    // string-based enums for glTF\n    ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n    TRIANGLES: 'meshopt_decodeIndexBuffer',\n    INDICES: 'meshopt_decodeIndexSequence',\n  }\n\n  generated = {\n    ready: promise,\n    supported: true,\n    decodeVertexBuffer(target, count, size, source, filter) {\n      decode(\n        instance.exports.meshopt_decodeVertexBuffer,\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n    decodeIndexBuffer(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source)\n    },\n    decodeIndexSequence(target, count, size, source) {\n      decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source)\n    },\n    decodeGltfBuffer(target, count, size, source, mode, filter) {\n      decode(\n        instance.exports[decoders[mode as keyof typeof decoders]],\n        target,\n        count,\n        size,\n        source,\n        instance.exports[filters[filter as keyof typeof filters]],\n      )\n    },\n  }\n\n  return generated\n}\n\nexport { MeshoptDecoder }\n","import {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  TrianglesDrawMode,\n  Vector3,\n  Mesh,\n  Line,\n  Points,\n  Material,\n  SkinnedMesh,\n} from 'three'\n\nimport { getWithKey } from '../types/helpers'\nimport type { TypedArrayConstructors, TypedArray } from '../types/shared'\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nexport const mergeBufferGeometries = (geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry | null => {\n  const isIndexed = geometries[0].index !== null\n\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n  const attributes: { [key: string]: Array<InterleavedBufferAttribute | BufferAttribute> } = {}\n  const morphAttributes: { [key: string]: Array<BufferAttribute | InterleavedBufferAttribute>[] } = {}\n\n  const morphTargetsRelative = geometries[0].morphTargetsRelative\n\n  const mergedGeometry = new BufferGeometry()\n\n  let offset = 0\n\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',\n      )\n      return null\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. All geometries must have compatible attributes; make sure \"' +\n            name +\n            '\" attribute exists among all geometries, or in none of them.',\n        )\n        return null\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = []\n      }\n\n      attributes[name].push(geom.attributes[name])\n\n      attributesCount++\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. Make sure all geometries have the same number of attributes.',\n      )\n      return null\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. .morphTargetsRelative must be consistent throughout all geometries.',\n      )\n      return null\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '.  .morphAttributes must be consistent throughout all geometries.',\n        )\n        return null\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n      morphAttributes[name].push(geom.morphAttributes[name])\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n    mergedGeometry.userData.mergedUserData.push(geom.userData)\n\n    if (useGroups) {\n      let count\n\n      if (geom.index) {\n        count = geom.index.count\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. The geometry must have either an index or a position attribute',\n        )\n        return null\n      }\n\n      mergedGeometry.addGroup(offset, count, i)\n\n      offset += count\n    }\n  })\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0\n    const mergedIndex: number[] = []\n\n    geometries.forEach((geom) => {\n      const index = geom.index as BufferAttribute\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset)\n      }\n\n      indexOffset += geom.attributes.position.count\n    })\n\n    mergedGeometry.setIndex(mergedIndex)\n  }\n\n  // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name] as BufferAttribute[])\n\n    if (!mergedAttribute) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.',\n      )\n      return null\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute)\n  }\n\n  // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length\n\n    if (numMorphTargets === 0) break\n\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n    mergedGeometry.morphAttributes[name] = []\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = []\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i])\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge as BufferAttribute[])\n\n      if (!mergedMorphAttribute) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' +\n            name +\n            ' morphAttribute.',\n        )\n        return null\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n    }\n  }\n\n  return mergedGeometry\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nexport const mergeBufferAttributes = (attributes: BufferAttribute[]): BufferAttribute | null | undefined => {\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let itemSize: number | undefined = undefined\n  let normalized: boolean | undefined = undefined\n  let arrayLength = 0\n\n  attributes.forEach((attr) => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',\n      )\n      return null\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    if (normalized === undefined) normalized = attr.normalized\n    if (normalized !== attr.normalized) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    arrayLength += attr.array.length\n  })\n\n  if (TypedArray && itemSize) {\n    // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset)\n      offset += attr.array.length\n    })\n\n    return new BufferAttribute(array, itemSize, normalized)\n  }\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nexport const interleaveAttributes = (attributes: BufferAttribute[]): InterleavedBufferAttribute[] | null => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let arrayLength = 0\n  let stride = 0\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i]\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved')\n      return null\n    }\n\n    arrayLength += attribute.array.length\n    stride += attribute.itemSize\n  }\n\n  // Create the set of buffer attributes\n  // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride)\n  let offset = 0\n  const res = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n  const setters = ['setX', 'setY', 'setZ', 'setW']\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j]\n    const itemSize = attribute.itemSize\n    const count = attribute.count\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized)\n    res.push(iba)\n\n    offset += itemSize\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k] as keyof InterleavedBufferAttribute) as InterleavedBufferAttribute[\n          | 'setX'\n          | 'setY'\n          | 'setZ'\n          | 'setW']\n        const get = getWithKey(attribute, getters[k] as keyof BufferAttribute) as BufferAttribute[\n          | 'getX'\n          | 'getY'\n          | 'getZ'\n          | 'getW']\n        set(c, get(c))\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name)\n    mem += attr.count * attr.itemSize * (attr.array as TypedArray).BYTES_PER_ELEMENT\n  }\n\n  const indices = geometry.getIndex()\n  mem += indices ? indices.count * indices.itemSize * (indices.array as TypedArray).BYTES_PER_ELEMENT : 0\n  return mem\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nexport function mergeVertices(geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n  tolerance = Math.max(tolerance, Number.EPSILON)\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex: {\n    [key: string]: number\n  } = {}\n  const indices = geometry.getIndex()\n  const positions = geometry.getAttribute('position')\n  const vertexCount = indices ? indices.count : positions.count\n\n  // next value for triangle indices\n  let nextIndex = 0\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes)\n  const attrArrays: {\n    [key: string]: []\n  } = {}\n  const morphAttrsArrays: {\n    [key: string]: Array<Array<BufferAttribute | InterleavedBufferAttribute>>\n  } = {}\n  const newIndices = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n\n    attrArrays[name] = []\n\n    const morphAttr = geometry.morphAttributes[name]\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => [])\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance)\n  const shiftMultiplier = Math.pow(10, decimalShift)\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = ''\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j]\n      const attribute = geometry.getAttribute(name)\n      const itemSize = attribute.itemSize\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash])\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j]\n        const attribute = geometry.getAttribute(name)\n        const morphAttr = geometry.morphAttributes[name]\n        const itemSize = attribute.itemSize\n        const newarray = attrArrays[name]\n        const newMorphArrays = morphAttrsArrays[name]\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]\n          // @ts-ignore\n          newarray.push(attribute[getterFunc](index))\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index))\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex\n      newIndices.push(nextIndex)\n      nextIndex++\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone()\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n    const oldAttribute = geometry.getAttribute(name)\n    //@ts-expect-error  something to do with functions and constructors and new\n    const buffer = new (oldAttribute.array as TypedArray).constructor(attrArrays[name])\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized)\n\n    result.setAttribute(name, attribute)\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]\n        //@ts-expect-error something to do with functions and constructors and new\n        const buffer = new (oldMorphAttribute.array as TypedArray).constructor(morphAttrsArrays[name][j])\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized)\n        result.morphAttributes[name][j] = morphAttribute\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices)\n\n  return result\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nexport function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: number): BufferGeometry {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.')\n    return geometry\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex()\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = []\n\n      const position = geometry.getAttribute('position')\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i)\n        }\n\n        geometry.setIndex(indices)\n        index = geometry.getIndex()\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n        )\n        return geometry\n      }\n    }\n\n    //\n\n    const numberOfTriangles = (index as BufferAttribute).count - 2\n    const newIndices = []\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0))\n          newIndices.push(index.getX(i))\n          newIndices.push(index.getX(i + 1))\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i + 2))\n          } else {\n            newIndices.push(index.getX(i + 2))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i))\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone()\n    newGeometry.setIndex(newIndices)\n    newGeometry.clearGroups()\n\n    return newGeometry\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode)\n    return geometry\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nexport type ComputedMorphedAttribute = {\n  positionAttribute: BufferAttribute | InterleavedBufferAttribute\n  normalAttribute: BufferAttribute | InterleavedBufferAttribute\n  morphedPositionAttribute: Float32BufferAttribute\n  morphedNormalAttribute: Float32BufferAttribute\n}\n\nexport function computeMorphedAttributes(object: Mesh | Line | Points): ComputedMorphedAttribute | null {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.')\n    return null\n  }\n\n  const _vA = new Vector3()\n  const _vB = new Vector3()\n  const _vC = new Vector3()\n\n  const _tempA = new Vector3()\n  const _tempB = new Vector3()\n  const _tempC = new Vector3()\n\n  const _morphA = new Vector3()\n  const _morphB = new Vector3()\n  const _morphC = new Vector3()\n\n  function _calculateMorphedAttributeData(\n    object: Mesh | Line | Points,\n    material: Material,\n    attribute: BufferAttribute | InterleavedBufferAttribute,\n    morphAttribute: (BufferAttribute | InterleavedBufferAttribute)[],\n    morphTargetsRelative: boolean,\n    a: number,\n    b: number,\n    c: number,\n    modifiedAttributeArray: Float32Array,\n  ): void {\n    _vA.fromBufferAttribute(attribute, a)\n    _vB.fromBufferAttribute(attribute, b)\n    _vC.fromBufferAttribute(attribute, c)\n\n    const morphInfluences = object.morphTargetInfluences\n\n    if (\n      // @ts-ignore\n      material.morphTargets &&\n      morphAttribute &&\n      morphInfluences\n    ) {\n      _morphA.set(0, 0, 0)\n      _morphB.set(0, 0, 0)\n      _morphC.set(0, 0, 0)\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i]\n        const morph = morphAttribute[i]\n\n        if (influence === 0) continue\n\n        _tempA.fromBufferAttribute(morph, a)\n        _tempB.fromBufferAttribute(morph, b)\n        _tempC.fromBufferAttribute(morph, c)\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence)\n          _morphB.addScaledVector(_tempB, influence)\n          _morphC.addScaledVector(_tempC, influence)\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence)\n          _morphB.addScaledVector(_tempB.sub(_vB), influence)\n          _morphC.addScaledVector(_tempC.sub(_vC), influence)\n        }\n      }\n\n      _vA.add(_morphA)\n      _vB.add(_morphB)\n      _vC.add(_morphC)\n    }\n\n    if ((object as SkinnedMesh).isSkinnedMesh) {\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(b, _vB)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(c, _vC)\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x\n    modifiedAttributeArray[a * 3 + 1] = _vA.y\n    modifiedAttributeArray[a * 3 + 2] = _vA.z\n    modifiedAttributeArray[b * 3 + 0] = _vB.x\n    modifiedAttributeArray[b * 3 + 1] = _vB.y\n    modifiedAttributeArray[b * 3 + 2] = _vB.z\n    modifiedAttributeArray[c * 3 + 0] = _vC.x\n    modifiedAttributeArray[c * 3 + 1] = _vC.y\n    modifiedAttributeArray[c * 3 + 2] = _vC.z\n  }\n\n  const geometry = object.geometry\n  const material = object.material\n\n  let a, b, c\n  const index = geometry.index\n  const positionAttribute = geometry.attributes.position\n  const morphPosition = geometry.morphAttributes.position\n  const morphTargetsRelative = geometry.morphTargetsRelative\n  const normalAttribute = geometry.attributes.normal\n  const morphNormal = geometry.morphAttributes.position\n\n  const groups = geometry.groups\n  const drawRange = geometry.drawRange\n  let i, j, il, jl\n  let group, groupMaterial\n  let start, end\n\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize)\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize)\n\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j)\n          b = index.getX(j + 1)\n          c = index.getX(j + 2)\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(index.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i)\n        b = index.getX(i + 1)\n        c = index.getX(i + 2)\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j\n          b = j + 1\n          c = j + 2\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i\n        b = i + 1\n        c = i + 2\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3)\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3)\n\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute,\n  }\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * Backwards compatible with code such as @react-three/drei's `<RoundedBox>`\n * which uses this method to operate on the original geometry.\n *\n * As of this writing, BufferGeometry.toNonIndexed() warns if the geometry is\n * non-indexed and returns `this`, i.e. the same geometry on which it was called:\n * `BufferGeometry is already non-indexed.`\n *\n * @param geometry\n * @param creaseAngle\n */\nexport function toCreasedNormals(geometry: BufferGeometry, creaseAngle = Math.PI / 3 /* 60 degrees */): BufferGeometry {\n  const creaseDot = Math.cos(creaseAngle)\n  const hashMultiplier = (1 + 1e-10) * 1e2\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()]\n  const tempVec1 = new Vector3()\n  const tempVec2 = new Vector3()\n  const tempNorm = new Vector3()\n  const tempNorm2 = new Vector3()\n\n  // hashes a vector\n  function hashVertex(v: Vector3): string {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n    return `${x},${y},${z}`\n  }\n\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry\n  const posAttr = resultGeometry.attributes.position\n  const vertexMap: { [key: string]: Vector3[] } = {}\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize()\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = []\n      }\n\n      vertexMap[hash].push(normal)\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3)\n  const normAttr = new BufferAttribute(normalArray, 3, false)\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize()\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      const otherNormals = vertexMap[hash]\n      tempNorm2.set(0, 0, 0)\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k]\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm)\n        }\n      }\n\n      tempNorm2.normalize()\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr)\n  return resultGeometry\n}\n","export function decodeText(array) {\n  if (typeof TextDecoder !== 'undefined') {\n    return new TextDecoder().decode(array)\n  }\n\n  // Avoid the String.fromCharCode.apply(null, array) shortcut, which\n  // throws a \"maximum call stack size exceeded\" error for large arrays.\n\n  let s = ''\n\n  for (let i = 0, il = array.length; i < il; i++) {\n    // Implicitly assumes little-endian.\n    s += String.fromCharCode(array[i])\n  }\n\n  try {\n    // merges multi-byte utf-8 characters.\n\n    return decodeURIComponent(escape(s))\n  } catch (e) {\n    // see https://github.com/mrdoob/three.js/issues/16358\n\n    return s\n  }\n}\n","import {\n  AnimationClip,\n  Bone,\n  Box3,\n  BufferAttribute,\n  BufferGeometry,\n  ClampToEdgeWrapping,\n  Color,\n  DirectionalLight,\n  DoubleSide,\n  FileLoader,\n  FrontSide,\n  Group,\n  ImageBitmapLoader,\n  InstancedMesh,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  Interpolant,\n  InterpolateDiscrete,\n  InterpolateLinear,\n  Line,\n  LineBasicMaterial,\n  LineLoop,\n  LineSegments,\n  LinearFilter,\n  LinearMipmapLinearFilter,\n  LinearMipmapNearestFilter,\n  Loader,\n  LoaderUtils,\n  Material,\n  MathUtils,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MirroredRepeatWrapping,\n  NearestFilter,\n  NearestMipmapLinearFilter,\n  NearestMipmapNearestFilter,\n  NumberKeyframeTrack,\n  Object3D,\n  OrthographicCamera,\n  PerspectiveCamera,\n  PointLight,\n  Points,\n  PointsMaterial,\n  PropertyBinding,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  RepeatWrapping,\n  Skeleton,\n  SkinnedMesh,\n  Sphere,\n  SpotLight,\n  Texture,\n  TextureLoader,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  Vector2,\n  Vector3,\n  VectorKeyframeTrack,\n  InstancedBufferAttribute,\n} from 'three'\nimport { toTrianglesDrawMode } from '../utils/BufferGeometryUtils'\nimport { version } from '../_polyfill/constants'\nimport { decodeText } from '../_polyfill/LoaderUtils'\n\nconst SRGBColorSpace = 'srgb'\nconst LinearSRGBColorSpace = 'srgb-linear'\nconst sRGBEncoding = 3001\nconst LinearEncoding = 3000\n\nclass GLTFLoader extends Loader {\n  constructor(manager) {\n    super(manager)\n\n    this.dracoLoader = null\n    this.ktx2Loader = null\n    this.meshoptDecoder = null\n\n    this.pluginCallbacks = []\n\n    this.register(function (parser) {\n      return new GLTFMaterialsClearcoatExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsDispersionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureBasisUExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureWebPExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFTextureAVIFExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSheenExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsTransmissionExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsVolumeExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIorExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsEmissiveStrengthExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsSpecularExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsIridescenceExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsAnisotropyExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMaterialsBumpExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFLightsExtension(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshoptCompression(parser)\n    })\n\n    this.register(function (parser) {\n      return new GLTFMeshGpuInstancing(parser)\n    })\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    let resourcePath\n\n    if (this.resourcePath !== '') {\n      resourcePath = this.resourcePath\n    } else if (this.path !== '') {\n      // If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\n      // Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\n      // resourcePath = 'https://my-cnd-server.com/assets/models/'\n      // referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\n      // referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\n      const relativeUrl = LoaderUtils.extractUrlBase(url)\n      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path)\n    } else {\n      resourcePath = LoaderUtils.extractUrlBase(url)\n    }\n\n    // Tells the LoadingManager to track an extra item, which resolves after\n    // the model is fully loaded. This means the count of items loaded will\n    // be incorrect, but ensures manager.onLoad() does not fire early.\n    this.manager.itemStart(url)\n\n    const _onError = function (e) {\n      if (onError) {\n        onError(e)\n      } else {\n        console.error(e)\n      }\n\n      scope.manager.itemError(url)\n      scope.manager.itemEnd(url)\n    }\n\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setResponseType('arraybuffer')\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      function (data) {\n        try {\n          scope.parse(\n            data,\n            resourcePath,\n            function (gltf) {\n              onLoad(gltf)\n\n              scope.manager.itemEnd(url)\n            },\n            _onError,\n          )\n        } catch (e) {\n          _onError(e)\n        }\n      },\n      onProgress,\n      _onError,\n    )\n  }\n\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader\n    return this\n  }\n\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".')\n  }\n\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader\n    return this\n  }\n\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder\n    return this\n  }\n\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback)\n    }\n\n    return this\n  }\n\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)\n    }\n\n    return this\n  }\n\n  parse(data, path, onLoad, onError) {\n    let json\n    const extensions = {}\n    const plugins = {}\n\n    if (typeof data === 'string') {\n      json = JSON.parse(data)\n    } else if (data instanceof ArrayBuffer) {\n      const magic = decodeText(new Uint8Array(data.slice(0, 4)))\n\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)\n        } catch (error) {\n          if (onError) onError(error)\n          return\n        }\n\n        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)\n      } else {\n        json = JSON.parse(decodeText(new Uint8Array(data)))\n      }\n    } else {\n      json = data\n    }\n\n    if (json.asset === undefined || json.asset.version[0] < 2) {\n      if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'))\n      return\n    }\n\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || '',\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder,\n    })\n\n    parser.fileLoader.setRequestHeader(this.requestHeader)\n\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser)\n\n      if (!plugin.name) console.error('THREE.GLTFLoader: Invalid plugin found: missing name')\n\n      plugins[plugin.name] = plugin\n\n      // Workaround to avoid determining as unknown extension\n      // in addUnknownExtensionsToUserData().\n      // Remove this workaround if we move all the existing\n      // extension handlers to plugin system\n      extensions[plugin.name] = true\n    }\n\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i]\n        const extensionsRequired = json.extensionsRequired || []\n\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension()\n            break\n\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader)\n            break\n\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension()\n            break\n\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension()\n            break\n\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".')\n            }\n        }\n      }\n    }\n\n    parser.setExtensions(extensions)\n    parser.setPlugins(plugins)\n    parser.parse(onLoad, onError)\n  }\n\n  parseAsync(data, path) {\n    const scope = this\n\n    return new Promise(function (resolve, reject) {\n      scope.parse(data, path, resolve, reject)\n    })\n  }\n}\n\n/* GLTFREGISTRY */\n\nfunction GLTFRegistry() {\n  let objects = {}\n\n  return {\n    get: function (key) {\n      return objects[key]\n    },\n\n    add: function (key, object) {\n      objects[key] = object\n    },\n\n    remove: function (key) {\n      delete objects[key]\n    },\n\n    removeAll: function () {\n      objects = {}\n    },\n  }\n}\n\n/*********************************/\n/********** EXTENSIONS ***********/\n/*********************************/\n\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: 'KHR_binary_glTF',\n  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\n  KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\n  KHR_MATERIALS_IOR: 'KHR_materials_ior',\n  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\n  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\n  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\n  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\n  KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\n  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',\n  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',\n  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\n  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\n  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\n  EXT_MATERIALS_BUMP: 'EXT_materials_bump',\n  EXT_TEXTURE_WEBP: 'EXT_texture_webp',\n  EXT_TEXTURE_AVIF: 'EXT_texture_avif',\n  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\n  EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing',\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL\n\n    // Object3D instance caches\n    this.cache = { refs: {}, uses: {} }\n  }\n\n  _markDefs() {\n    const parser = this.parser\n    const nodeDefs = this.parser.json.nodes || []\n\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)\n      }\n    }\n  }\n\n  _loadLight(lightIndex) {\n    const parser = this.parser\n    const cacheKey = 'light:' + lightIndex\n    let dependency = parser.cache.get(cacheKey)\n\n    if (dependency) return dependency\n\n    const json = parser.json\n    const extensions = (json.extensions && json.extensions[this.name]) || {}\n    const lightDefs = extensions.lights || []\n    const lightDef = lightDefs[lightIndex]\n    let lightNode\n\n    const color = new Color(0xffffff)\n\n    if (lightDef.color !== undefined)\n      color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace)\n\n    const range = lightDef.range !== undefined ? lightDef.range : 0\n\n    switch (lightDef.type) {\n      case 'directional':\n        lightNode = new DirectionalLight(color)\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      case 'point':\n        lightNode = new PointLight(color)\n        lightNode.distance = range\n        break\n\n      case 'spot':\n        lightNode = new SpotLight(color)\n        lightNode.distance = range\n        // Handle spotlight properties.\n        lightDef.spot = lightDef.spot || {}\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0\n        lightDef.spot.outerConeAngle =\n          lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0\n        lightNode.angle = lightDef.spot.outerConeAngle\n        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle\n        lightNode.target.position.set(0, 0, -1)\n        lightNode.add(lightNode.target)\n        break\n\n      default:\n        throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)\n    }\n\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\n    // here, because node-level parsing will only override position if explicitly specified.\n    lightNode.position.set(0, 0, 0)\n\n    lightNode.decay = 2\n\n    assignExtrasToUserData(lightNode, lightDef)\n\n    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity\n\n    lightNode.name = parser.createUniqueName(lightDef.name || 'light_' + lightIndex)\n\n    dependency = Promise.resolve(lightNode)\n\n    parser.cache.add(cacheKey, dependency)\n\n    return dependency\n  }\n\n  getDependency(type, index) {\n    if (type !== 'light') return\n\n    return this._loadLight(index)\n  }\n\n  createNodeAttachment(nodeIndex) {\n    const self = this\n    const parser = this.parser\n    const json = parser.json\n    const nodeDef = json.nodes[nodeIndex]\n    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}\n    const lightIndex = lightDef.light\n\n    if (lightIndex === undefined) return null\n\n    return this._loadLight(lightIndex).then(function (light) {\n      return parser._getNodeRef(self.cache, lightIndex, light)\n    })\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT\n  }\n\n  getMaterialType() {\n    return MeshBasicMaterial\n  }\n\n  extendParams(materialParams, materialDef, parser) {\n    const pending = []\n\n    materialParams.color = new Color(1.0, 1.0, 1.0)\n    materialParams.opacity = 1.0\n\n    const metallicRoughness = materialDef.pbrMetallicRoughness\n\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength\n\n    if (emissiveStrength !== undefined) {\n      materialParams.emissiveIntensity = emissiveStrength\n    }\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.clearcoatFactor !== undefined) {\n      materialParams.clearcoat = extension.clearcoatFactor\n    }\n\n    if (extension.clearcoatTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))\n    }\n\n    if (extension.clearcoatRoughnessFactor !== undefined) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor\n    }\n\n    if (extension.clearcoatRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))\n    }\n\n    if (extension.clearcoatNormalTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture))\n\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\n        const scale = extension.clearcoatNormalTexture.scale\n\n        materialParams.clearcoatNormalScale = new Vector2(scale, scale)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\n */\nclass GLTFMaterialsDispersionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.iridescenceFactor !== undefined) {\n      materialParams.iridescence = extension.iridescenceFactor\n    }\n\n    if (extension.iridescenceTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))\n    }\n\n    if (extension.iridescenceIor !== undefined) {\n      materialParams.iridescenceIOR = extension.iridescenceIor\n    }\n\n    if (materialParams.iridescenceThicknessRange === undefined) {\n      materialParams.iridescenceThicknessRange = [100, 400]\n    }\n\n    if (extension.iridescenceThicknessMinimum !== undefined) {\n      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum\n    }\n\n    if (extension.iridescenceThicknessMaximum !== undefined) {\n      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum\n    }\n\n    if (extension.iridescenceThicknessTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    materialParams.sheenColor = new Color(0, 0, 0)\n    materialParams.sheenRoughness = 0\n    materialParams.sheen = 1\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.sheenColorFactor !== undefined) {\n      const colorFactor = extension.sheenColorFactor\n      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace)\n    }\n\n    if (extension.sheenRoughnessFactor !== undefined) {\n      materialParams.sheenRoughness = extension.sheenRoughnessFactor\n    }\n\n    if (extension.sheenColorTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace))\n    }\n\n    if (extension.sheenRoughnessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.transmissionFactor !== undefined) {\n      materialParams.transmission = extension.transmissionFactor\n    }\n\n    if (extension.transmissionTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0\n\n    if (extension.thicknessTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))\n    }\n\n    materialParams.attenuationDistance = extension.attenuationDistance || Infinity\n\n    const colorArray = extension.attenuationColor || [1, 1, 1]\n    materialParams.attenuationColor = new Color().setRGB(\n      colorArray[0],\n      colorArray[1],\n      colorArray[2],\n      LinearSRGBColorSpace,\n    )\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n */\nclass GLTFMaterialsIorExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_IOR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5\n\n    return Promise.resolve()\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0\n\n    if (extension.specularTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))\n    }\n\n    const colorArray = extension.specularColorFactor || [1, 1, 1]\n    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace)\n\n    if (extension.specularColorTexture !== undefined) {\n      pending.push(\n        parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace),\n      )\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n */\nclass GLTFMaterialsBumpExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_MATERIALS_BUMP\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0\n\n    if (extension.bumpTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'bumpMap', extension.bumpTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * Materials anisotropy Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY\n  }\n\n  getMaterialType(materialIndex) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null\n\n    return MeshPhysicalMaterial\n  }\n\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser\n    const materialDef = parser.json.materials[materialIndex]\n\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve()\n    }\n\n    const pending = []\n\n    const extension = materialDef.extensions[this.name]\n\n    if (extension.anisotropyStrength !== undefined) {\n      materialParams.anisotropy = extension.anisotropyStrength\n    }\n\n    if (extension.anisotropyRotation !== undefined) {\n      materialParams.anisotropyRotation = extension.anisotropyRotation\n    }\n\n    if (extension.anisotropyTexture !== undefined) {\n      pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))\n    }\n\n    return Promise.all(pending)\n  }\n}\n\n/**\n * BasisU Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\n */\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU\n  }\n\n  loadTexture(textureIndex) {\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[this.name]\n    const loader = parser.options.ktx2Loader\n\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')\n      } else {\n        // Assumes that the extension is optional and that a fallback texture is present\n        return null\n      }\n    }\n\n    return parser.loadTextureImage(textureIndex, extension.source, loader)\n  }\n}\n\n/**\n * WebP Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\n */\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\n        // WebP images, unfortunately.\n        image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'\n\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * AVIF Texture Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\n */\nclass GLTFTextureAVIFExtension {\n  constructor(parser) {\n    this.parser = parser\n    this.name = EXTENSIONS.EXT_TEXTURE_AVIF\n    this.isSupported = null\n  }\n\n  loadTexture(textureIndex) {\n    const name = this.name\n    const parser = this.parser\n    const json = parser.json\n\n    const textureDef = json.textures[textureIndex]\n\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null\n    }\n\n    const extension = textureDef.extensions[name]\n    const source = json.images[extension.source]\n\n    let loader = parser.textureLoader\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.detectSupport().then(function (isSupported) {\n      if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader)\n\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')\n      }\n\n      // Fall back to PNG or JPEG.\n      return parser.loadTexture(textureIndex)\n    })\n  }\n\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function (resolve) {\n        const image = new Image()\n\n        // Lossy test image.\n        image.src =\n          'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI='\n        image.onload = image.onerror = function () {\n          resolve(image.height === 1)\n        }\n      })\n    }\n\n    return this.isSupported\n  }\n}\n\n/**\n * meshopt BufferView Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\n */\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION\n    this.parser = parser\n  }\n\n  loadBufferView(index) {\n    const json = this.parser.json\n    const bufferView = json.bufferViews[index]\n\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name]\n\n      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)\n      const decoder = this.parser.options.meshoptDecoder\n\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')\n        } else {\n          // Assumes that the extension is optional and that fallback buffer data is present\n          return null\n        }\n      }\n\n      return buffer.then(function (res) {\n        const byteOffset = extensionDef.byteOffset || 0\n        const byteLength = extensionDef.byteLength || 0\n\n        const count = extensionDef.count\n        const stride = extensionDef.byteStride\n\n        const source = new Uint8Array(res, byteOffset, byteLength)\n\n        if (decoder.decodeGltfBufferAsync) {\n          return decoder\n            .decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter)\n            .then(function (res) {\n              return res.buffer\n            })\n        } else {\n          // Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\n          return decoder.ready.then(function () {\n            const result = new ArrayBuffer(count * stride)\n            decoder.decodeGltfBuffer(\n              new Uint8Array(result),\n              count,\n              stride,\n              source,\n              extensionDef.mode,\n              extensionDef.filter,\n            )\n            return result\n          })\n        }\n      })\n    } else {\n      return null\n    }\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n */\nclass GLTFMeshGpuInstancing {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING\n    this.parser = parser\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.parser.json\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {\n      return null\n    }\n\n    const meshDef = json.meshes[nodeDef.mesh]\n\n    // No Points or Lines + Instancing support yet\n\n    for (const primitive of meshDef.primitives) {\n      if (\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\n        primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\n        primitive.mode !== undefined\n      ) {\n        return null\n      }\n    }\n\n    const extensionDef = nodeDef.extensions[this.name]\n    const attributesDef = extensionDef.attributes\n\n    // @TODO: Can we support InstancedMesh + SkinnedMesh?\n\n    const pending = []\n    const attributes = {}\n\n    for (const key in attributesDef) {\n      pending.push(\n        this.parser.getDependency('accessor', attributesDef[key]).then((accessor) => {\n          attributes[key] = accessor\n          return attributes[key]\n        }),\n      )\n    }\n\n    if (pending.length < 1) {\n      return null\n    }\n\n    pending.push(this.parser.createNodeMesh(nodeIndex))\n\n    return Promise.all(pending).then((results) => {\n      const nodeObject = results.pop()\n      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject]\n      const count = results[0].count // All attribute counts should be same\n      const instancedMeshes = []\n\n      for (const mesh of meshes) {\n        // Temporal variables\n        const m = new Matrix4()\n        const p = new Vector3()\n        const q = new Quaternion()\n        const s = new Vector3(1, 1, 1)\n\n        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count)\n\n        for (let i = 0; i < count; i++) {\n          if (attributes.TRANSLATION) {\n            p.fromBufferAttribute(attributes.TRANSLATION, i)\n          }\n\n          if (attributes.ROTATION) {\n            q.fromBufferAttribute(attributes.ROTATION, i)\n          }\n\n          if (attributes.SCALE) {\n            s.fromBufferAttribute(attributes.SCALE, i)\n          }\n\n          instancedMesh.setMatrixAt(i, m.compose(p, q, s))\n        }\n\n        // Add instance attributes to the geometry, excluding TRS.\n        for (const attributeName in attributes) {\n          if (attributeName === '_COLOR_0') {\n            const attr = attributes[attributeName]\n            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized)\n          } else if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {\n            mesh.geometry.setAttribute(attributeName, attributes[attributeName])\n          }\n        }\n\n        // Just in case\n        Object3D.prototype.copy.call(instancedMesh, mesh)\n\n        this.parser.assignFinalMaterial(instancedMesh)\n\n        instancedMeshes.push(instancedMesh)\n      }\n\n      if (nodeObject.isGroup) {\n        nodeObject.clear()\n\n        nodeObject.add(...instancedMeshes)\n\n        return nodeObject\n      }\n\n      return instancedMeshes[0]\n    })\n  }\n}\n\n/* BINARY EXTENSION */\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF'\nconst BINARY_EXTENSION_HEADER_LENGTH = 12\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 }\n\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF\n    this.content = null\n    this.body = null\n\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)\n\n    this.header = {\n      magic: decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true),\n    }\n\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')\n    } else if (this.header.version < 2.0) {\n      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')\n    }\n\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)\n    let chunkIndex = 0\n\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      const chunkType = chunkView.getUint32(chunkIndex, true)\n      chunkIndex += 4\n\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength)\n        this.content = decodeText(contentArray)\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex\n        this.body = data.slice(byteOffset, byteOffset + chunkLength)\n      }\n\n      // Clients must ignore chunks with unknown types.\n\n      chunkIndex += chunkLength\n    }\n\n    if (this.content === null) {\n      throw new Error('THREE.GLTFLoader: JSON content not found.')\n    }\n  }\n}\n\n/**\n * DRACO Mesh Compression Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n */\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')\n    }\n\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION\n    this.json = json\n    this.dracoLoader = dracoLoader\n    this.dracoLoader.preload()\n  }\n\n  decodePrimitive(primitive, parser) {\n    const json = this.json\n    const dracoLoader = this.dracoLoader\n    const bufferViewIndex = primitive.extensions[this.name].bufferView\n    const gltfAttributeMap = primitive.extensions[this.name].attributes\n    const threeAttributeMap = {}\n    const attributeNormalizedMap = {}\n    const attributeTypeMap = {}\n\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]\n    }\n\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase()\n\n      if (gltfAttributeMap[attributeName] !== undefined) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]]\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n        attributeTypeMap[threeAttributeName] = componentType.name\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true\n      }\n    }\n\n    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n      return new Promise(function (resolve, reject) {\n        dracoLoader.decodeDracoFile(\n          bufferView,\n          function (geometry) {\n            for (const attributeName in geometry.attributes) {\n              const attribute = geometry.attributes[attributeName]\n              const normalized = attributeNormalizedMap[attributeName]\n\n              if (normalized !== undefined) attribute.normalized = normalized\n            }\n\n            resolve(geometry)\n          },\n          threeAttributeMap,\n          attributeTypeMap,\n          LinearSRGBColorSpace,\n          reject,\n        )\n      })\n    })\n  }\n}\n\n/**\n * Texture Transform Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\n */\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM\n  }\n\n  extendTexture(texture, transform) {\n    if (\n      (transform.texCoord === undefined || transform.texCoord === texture.channel) &&\n      transform.offset === undefined &&\n      transform.rotation === undefined &&\n      transform.scale === undefined\n    ) {\n      // See https://github.com/mrdoob/three.js/issues/21819.\n      return texture\n    }\n\n    texture = texture.clone()\n\n    if (transform.texCoord !== undefined) {\n      texture.channel = transform.texCoord\n    }\n\n    if (transform.offset !== undefined) {\n      texture.offset.fromArray(transform.offset)\n    }\n\n    if (transform.rotation !== undefined) {\n      texture.rotation = transform.rotation\n    }\n\n    if (transform.scale !== undefined) {\n      texture.repeat.fromArray(transform.scale)\n    }\n\n    texture.needsUpdate = true\n\n    return texture\n  }\n}\n\n/**\n * Mesh Quantization Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\n */\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION\n  }\n}\n\n/*********************************/\n/********** INTERPOLATION ********/\n/*********************************/\n\n// Spline Interpolation\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\nclass GLTFCubicSplineInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer)\n  }\n\n  copySampleValue_(index) {\n    // Copies a sample value to the result buffer. See description of glTF\n    // CUBICSPLINE values layout in interpolate_() function below.\n\n    const result = this.resultBuffer,\n      values = this.sampleValues,\n      valueSize = this.valueSize,\n      offset = index * valueSize * 3 + valueSize\n\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i]\n    }\n\n    return result\n  }\n\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer\n    const values = this.sampleValues\n    const stride = this.valueSize\n\n    const stride2 = stride * 2\n    const stride3 = stride * 3\n\n    const td = t1 - t0\n\n    const p = (t - t0) / td\n    const pp = p * p\n    const ppp = pp * p\n\n    const offset1 = i1 * stride3\n    const offset0 = offset1 - stride3\n\n    const s2 = -2 * ppp + 3 * pp\n    const s3 = ppp - pp\n    const s0 = 1 - s2\n    const s1 = s3 - pp + p\n\n    // Layout of keyframe output values for CUBICSPLINE animations:\n    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n    for (let i = 0; i !== stride; i++) {\n      const p0 = values[offset0 + i + stride] // splineVertex_k\n      const m0 = values[offset0 + i + stride2] * td // outTangent_k * (t_k+1 - t_k)\n      const p1 = values[offset1 + i + stride] // splineVertex_k+1\n      const m1 = values[offset1 + i] * td // inTangent_k+1 * (t_k+1 - t_k)\n\n      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1\n    }\n\n    return result\n  }\n}\n\nconst _q = /* @__PURE__ */ new Quaternion()\n\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\n  interpolate_(i1, t0, t, t1) {\n    const result = super.interpolate_(i1, t0, t, t1)\n\n    _q.fromArray(result).normalize().toArray(result)\n\n    return result\n  }\n}\n\n/*********************************/\n/********** INTERNALS ************/\n/*********************************/\n\n/* CONSTANTS */\n\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  //FLOAT_MAT2: 35674,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123,\n}\n\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array,\n}\n\nconst WEBGL_FILTERS = {\n  9728: NearestFilter,\n  9729: LinearFilter,\n  9984: NearestMipmapNearestFilter,\n  9985: LinearMipmapNearestFilter,\n  9986: NearestMipmapLinearFilter,\n  9987: LinearMipmapLinearFilter,\n}\n\nconst WEBGL_WRAPPINGS = {\n  33071: ClampToEdgeWrapping,\n  33648: MirroredRepeatWrapping,\n  10497: RepeatWrapping,\n}\n\nconst WEBGL_TYPE_SIZES = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16,\n}\n\nconst ATTRIBUTES = {\n  POSITION: 'position',\n  NORMAL: 'normal',\n  TANGENT: 'tangent',\n  // uv => uv1, 4 uv channels\n  // https://github.com/mrdoob/three.js/pull/25943\n  // https://github.com/mrdoob/three.js/pull/25788\n  ...(version >= 152\n    ? {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv1',\n        TEXCOORD_2: 'uv2',\n        TEXCOORD_3: 'uv3',\n      }\n    : {\n        TEXCOORD_0: 'uv',\n        TEXCOORD_1: 'uv2',\n      }),\n\n  COLOR_0: 'color',\n  WEIGHTS_0: 'skinWeight',\n  JOINTS_0: 'skinIndex',\n}\n\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  translation: 'position',\n  rotation: 'quaternion',\n  weights: 'morphTargetInfluences',\n}\n\nconst INTERPOLATION = {\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n  // keyframe track will be initialized with a default interpolation type, then modified.\n  LINEAR: InterpolateLinear,\n  STEP: InterpolateDiscrete,\n}\n\nconst ALPHA_MODES = {\n  OPAQUE: 'OPAQUE',\n  MASK: 'MASK',\n  BLEND: 'BLEND',\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n */\nfunction createDefaultMaterial(cache) {\n  if (cache['DefaultMaterial'] === undefined) {\n    cache['DefaultMaterial'] = new MeshStandardMaterial({\n      color: 0xffffff,\n      emissive: 0x000000,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: FrontSide,\n    })\n  }\n\n  return cache['DefaultMaterial']\n}\n\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  // Add unknown glTF extensions to an object's userData.\n\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === undefined) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {}\n      object.userData.gltfExtensions[name] = objectDef.extensions[name]\n    }\n  }\n}\n\n/**\n * @param {Object3D|Material|BufferGeometry} object\n * @param {GLTF.definition} gltfDef\n */\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== undefined) {\n    if (typeof gltfDef.extras === 'object') {\n      Object.assign(object.userData, gltfDef.extras)\n    } else {\n      console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)\n    }\n  }\n}\n\n/**\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n *\n * @param {BufferGeometry} geometry\n * @param {Array<GLTF.Target>} targets\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false\n  let hasMorphNormal = false\n  let hasMorphColor = false\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (target.POSITION !== undefined) hasMorphPosition = true\n    if (target.NORMAL !== undefined) hasMorphNormal = true\n    if (target.COLOR_0 !== undefined) hasMorphColor = true\n\n    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break\n  }\n\n  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry)\n\n  const pendingPositionAccessors = []\n  const pendingNormalAccessors = []\n  const pendingColorAccessors = []\n\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i]\n\n    if (hasMorphPosition) {\n      const pendingAccessor =\n        target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position\n\n      pendingPositionAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphNormal) {\n      const pendingAccessor =\n        target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal\n\n      pendingNormalAccessors.push(pendingAccessor)\n    }\n\n    if (hasMorphColor) {\n      const pendingAccessor =\n        target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color\n\n      pendingColorAccessors.push(pendingAccessor)\n    }\n  }\n\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors),\n    Promise.all(pendingColorAccessors),\n  ]).then(function (accessors) {\n    const morphPositions = accessors[0]\n    const morphNormals = accessors[1]\n    const morphColors = accessors[2]\n\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals\n    if (hasMorphColor) geometry.morphAttributes.color = morphColors\n    geometry.morphTargetsRelative = true\n\n    return geometry\n  })\n}\n\n/**\n * @param {Mesh} mesh\n * @param {GLTF.Mesh} meshDef\n */\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets()\n\n  if (meshDef.weights !== undefined) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i]\n    }\n  }\n\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames\n\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {}\n\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')\n    }\n  }\n}\n\nfunction createPrimitiveKey(primitiveDef) {\n  let geometryKey\n\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n\n  if (dracoExtension) {\n    geometryKey =\n      'draco:' +\n      dracoExtension.bufferView +\n      ':' +\n      dracoExtension.indices +\n      ':' +\n      createAttributesKey(dracoExtension.attributes)\n  } else {\n    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode\n  }\n\n  if (primitiveDef.targets !== undefined) {\n    for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {\n      geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])\n    }\n  }\n\n  return geometryKey\n}\n\nfunction createAttributesKey(attributes) {\n  let attributesKey = ''\n\n  const keys = Object.keys(attributes).sort()\n\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'\n  }\n\n  return attributesKey\n}\n\nfunction getNormalizedComponentScale(constructor) {\n  // Reference:\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\n\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127\n\n    case Uint8Array:\n      return 1 / 255\n\n    case Int16Array:\n      return 1 / 32767\n\n    case Uint16Array:\n      return 1 / 65535\n\n    default:\n      throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')\n  }\n}\n\nfunction getImageURIMimeType(uri) {\n  if (uri.search(/\\.jpe?g($|\\?)/i) > 0 || uri.search(/^data\\:image\\/jpeg/) === 0) return 'image/jpeg'\n  if (uri.search(/\\.webp($|\\?)/i) > 0 || uri.search(/^data\\:image\\/webp/) === 0) return 'image/webp'\n\n  return 'image/png'\n}\n\nconst _identityMatrix = /* @__PURE__ */ new Matrix4()\n\n/* GLTF PARSER */\n\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json\n    this.extensions = {}\n    this.plugins = {}\n    this.options = options\n\n    // loader object cache\n    this.cache = new GLTFRegistry()\n\n    // associations between Three.js objects and glTF elements\n    this.associations = new Map()\n\n    // BufferGeometry caching\n    this.primitiveCache = {}\n\n    // Node cache\n    this.nodeCache = {}\n\n    // Object3D instance caches\n    this.meshCache = { refs: {}, uses: {} }\n    this.cameraCache = { refs: {}, uses: {} }\n    this.lightCache = { refs: {}, uses: {} }\n\n    this.sourceCache = {}\n    this.textureCache = {}\n\n    // Track node names, to ensure no duplicates\n    this.nodeNamesUsed = {}\n\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\n    // expensive work of uploading a texture to the GPU off the main thread.\n\n    let isSafari = false\n    let isFirefox = false\n    let firefoxVersion = -1\n\n    if (typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined') {\n      isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true\n      isFirefox = navigator.userAgent.indexOf('Firefox') > -1\n      firefoxVersion = isFirefox ? navigator.userAgent.match(/Firefox\\/([0-9]+)\\./)[1] : -1\n    }\n\n    if (typeof createImageBitmap === 'undefined' || isSafari || (isFirefox && firefoxVersion < 98)) {\n      this.textureLoader = new TextureLoader(this.options.manager)\n    } else {\n      this.textureLoader = new ImageBitmapLoader(this.options.manager)\n    }\n\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin)\n    this.textureLoader.setRequestHeader(this.options.requestHeader)\n\n    this.fileLoader = new FileLoader(this.options.manager)\n    this.fileLoader.setResponseType('arraybuffer')\n\n    if (this.options.crossOrigin === 'use-credentials') {\n      this.fileLoader.setWithCredentials(true)\n    }\n  }\n\n  setExtensions(extensions) {\n    this.extensions = extensions\n  }\n\n  setPlugins(plugins) {\n    this.plugins = plugins\n  }\n\n  parse(onLoad, onError) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    // Clear the loader cache\n    this.cache.removeAll()\n    this.nodeCache = {}\n\n    // Mark the special nodes/meshes in json for efficient parse\n    this._invokeAll(function (ext) {\n      return ext._markDefs && ext._markDefs()\n    })\n\n    Promise.all(\n      this._invokeAll(function (ext) {\n        return ext.beforeRoot && ext.beforeRoot()\n      }),\n    )\n      .then(function () {\n        return Promise.all([\n          parser.getDependencies('scene'),\n          parser.getDependencies('animation'),\n          parser.getDependencies('camera'),\n        ])\n      })\n      .then(function (dependencies) {\n        const result = {\n          scene: dependencies[0][json.scene || 0],\n          scenes: dependencies[0],\n          animations: dependencies[1],\n          cameras: dependencies[2],\n          asset: json.asset,\n          parser: parser,\n          userData: {},\n        }\n\n        addUnknownExtensionsToUserData(extensions, result, json)\n\n        assignExtrasToUserData(result, json)\n\n        return Promise.all(\n          parser._invokeAll(function (ext) {\n            return ext.afterRoot && ext.afterRoot(result)\n          }),\n        ).then(function () {\n          for (const scene of result.scenes) {\n            scene.updateMatrixWorld()\n          }\n\n          onLoad(result)\n        })\n      })\n      .catch(onError)\n  }\n\n  /**\n   * Marks the special nodes/meshes in json for efficient parse.\n   */\n  _markDefs() {\n    const nodeDefs = this.json.nodes || []\n    const skinDefs = this.json.skins || []\n    const meshDefs = this.json.meshes || []\n\n    // Nothing in the node definition indicates whether it is a Bone or an\n    // Object3D. Use the skins' joint references to mark bones.\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints\n\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true\n      }\n    }\n\n    // Iterate over all nodes, marking references to shared resources,\n    // as well as skeleton joints.\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex]\n\n      if (nodeDef.mesh !== undefined) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh)\n\n        // Nothing in the mesh definition indicates whether it is\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\n        // to mark SkinnedMesh if node has skin.\n        if (nodeDef.skin !== undefined) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true\n        }\n      }\n\n      if (nodeDef.camera !== undefined) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera)\n      }\n    }\n  }\n\n  /**\n   * Counts references to shared node / Object3D resources. These resources\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\n   * Textures) can be reused directly and are not marked here.\n   *\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n   */\n  _addNodeRef(cache, index) {\n    if (index === undefined) return\n\n    if (cache.refs[index] === undefined) {\n      cache.refs[index] = cache.uses[index] = 0\n    }\n\n    cache.refs[index]++\n  }\n\n  /** Returns a reference to a shared resource, cloning it if necessary. */\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1) return object\n\n    const ref = object.clone()\n\n    // Propagates mappings to the cloned object, prevents mappings on the\n    // original object from being lost.\n    const updateMappings = (original, clone) => {\n      const mappings = this.associations.get(original)\n      if (mappings != null) {\n        this.associations.set(clone, mappings)\n      }\n\n      for (const [i, child] of original.children.entries()) {\n        updateMappings(child, clone.children[i])\n      }\n    }\n\n    updateMappings(object, ref)\n\n    ref.name += '_instance_' + cache.uses[index]++\n\n    return ref\n  }\n\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.push(this)\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) return result\n    }\n\n    return null\n  }\n\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins)\n    extensions.unshift(this)\n\n    const pending = []\n\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i])\n\n      if (result) pending.push(result)\n    }\n\n    return pending\n  }\n\n  /**\n   * Requests the specified dependency asynchronously, with caching.\n   * @param {string} type\n   * @param {number} index\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\n   */\n  getDependency(type, index) {\n    const cacheKey = type + ':' + index\n    let dependency = this.cache.get(cacheKey)\n\n    if (!dependency) {\n      switch (type) {\n        case 'scene':\n          dependency = this.loadScene(index)\n          break\n\n        case 'node':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadNode && ext.loadNode(index)\n          })\n          break\n\n        case 'mesh':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMesh && ext.loadMesh(index)\n          })\n          break\n\n        case 'accessor':\n          dependency = this.loadAccessor(index)\n          break\n\n        case 'bufferView':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadBufferView && ext.loadBufferView(index)\n          })\n          break\n\n        case 'buffer':\n          dependency = this.loadBuffer(index)\n          break\n\n        case 'material':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadMaterial && ext.loadMaterial(index)\n          })\n          break\n\n        case 'texture':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadTexture && ext.loadTexture(index)\n          })\n          break\n\n        case 'skin':\n          dependency = this.loadSkin(index)\n          break\n\n        case 'animation':\n          dependency = this._invokeOne(function (ext) {\n            return ext.loadAnimation && ext.loadAnimation(index)\n          })\n          break\n\n        case 'camera':\n          dependency = this.loadCamera(index)\n          break\n\n        default:\n          dependency = this._invokeOne(function (ext) {\n            return ext != this && ext.getDependency && ext.getDependency(type, index)\n          })\n\n          if (!dependency) {\n            throw new Error('Unknown type: ' + type)\n          }\n\n          break\n      }\n\n      this.cache.add(cacheKey, dependency)\n    }\n\n    return dependency\n  }\n\n  /**\n   * Requests all dependencies of the specified type asynchronously, with caching.\n   * @param {string} type\n   * @return {Promise<Array<Object>>}\n   */\n  getDependencies(type) {\n    let dependencies = this.cache.get(type)\n\n    if (!dependencies) {\n      const parser = this\n      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []\n\n      dependencies = Promise.all(\n        defs.map(function (def, index) {\n          return parser.getDependency(type, index)\n        }),\n      )\n\n      this.cache.add(type, dependencies)\n    }\n\n    return dependencies\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex]\n    const loader = this.fileLoader\n\n    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')\n    }\n\n    // If present, GLB container is required to be the first buffer.\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)\n    }\n\n    const options = this.options\n\n    return new Promise(function (resolve, reject) {\n      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'))\n      })\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n   * @param {number} bufferViewIndex\n   * @return {Promise<ArrayBuffer>}\n   */\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex]\n\n    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n      const byteLength = bufferViewDef.byteLength || 0\n      const byteOffset = bufferViewDef.byteOffset || 0\n      return buffer.slice(byteOffset, byteOffset + byteLength)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n   * @param {number} accessorIndex\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\n   */\n  loadAccessor(accessorIndex) {\n    const parser = this\n    const json = this.json\n\n    const accessorDef = this.json.accessors[accessorIndex]\n\n    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n      const normalized = accessorDef.normalized === true\n\n      const array = new TypedArray(accessorDef.count * itemSize)\n      return Promise.resolve(new BufferAttribute(array, itemSize, normalized))\n    }\n\n    const pendingBufferViews = []\n\n    if (accessorDef.bufferView !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))\n    } else {\n      pendingBufferViews.push(null)\n    }\n\n    if (accessorDef.sparse !== undefined) {\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView))\n      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))\n    }\n\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\n      const bufferView = bufferViews[0]\n\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]\n\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT\n      const itemBytes = elementBytes * itemSize\n      const byteOffset = accessorDef.byteOffset || 0\n      const byteStride =\n        accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined\n      const normalized = accessorDef.normalized === true\n      let array, bufferAttribute\n\n      // The buffer is not interleaved if the stride is the item size in bytes.\n      if (byteStride && byteStride !== itemBytes) {\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\n        // This makes sure that IBA.count reflects accessor.count properly\n        const ibSlice = Math.floor(byteOffset / byteStride)\n        const ibCacheKey =\n          'InterleavedBuffer:' +\n          accessorDef.bufferView +\n          ':' +\n          accessorDef.componentType +\n          ':' +\n          ibSlice +\n          ':' +\n          accessorDef.count\n        let ib = parser.cache.get(ibCacheKey)\n\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, (accessorDef.count * byteStride) / elementBytes)\n\n          // Integer parameters to IB/IBA are in array elements, not bytes.\n          ib = new InterleavedBuffer(array, byteStride / elementBytes)\n\n          parser.cache.add(ibCacheKey, ib)\n        }\n\n        bufferAttribute = new InterleavedBufferAttribute(\n          ib,\n          itemSize,\n          (byteOffset % byteStride) / elementBytes,\n          normalized,\n        )\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize)\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)\n        }\n\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized)\n      }\n\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n      if (accessorDef.sparse !== undefined) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]\n\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0\n\n        const sparseIndices = new TypedArrayIndices(\n          bufferViews[1],\n          byteOffsetIndices,\n          accessorDef.sparse.count * itemSizeIndices,\n        )\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize)\n\n        if (bufferView !== null) {\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n          bufferAttribute = new BufferAttribute(\n            bufferAttribute.array.slice(),\n            bufferAttribute.itemSize,\n            bufferAttribute.normalized,\n          )\n        }\n\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i]\n\n          bufferAttribute.setX(index, sparseValues[i * itemSize])\n          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1])\n          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])\n          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3])\n          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')\n        }\n      }\n\n      return bufferAttribute\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture|null>}\n   */\n  loadTexture(textureIndex) {\n    const json = this.json\n    const options = this.options\n    const textureDef = json.textures[textureIndex]\n    const sourceIndex = textureDef.source\n    const sourceDef = json.images[sourceIndex]\n\n    let loader = this.textureLoader\n\n    if (sourceDef.uri) {\n      const handler = options.manager.getHandler(sourceDef.uri)\n      if (handler !== null) loader = handler\n    }\n\n    return this.loadTextureImage(textureIndex, sourceIndex, loader)\n  }\n\n  loadTextureImage(textureIndex, sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n\n    const textureDef = json.textures[textureIndex]\n    const sourceDef = json.images[sourceIndex]\n\n    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler\n\n    if (this.textureCache[cacheKey]) {\n      // See https://github.com/mrdoob/three.js/issues/21559.\n      return this.textureCache[cacheKey]\n    }\n\n    const promise = this.loadImageSource(sourceIndex, loader)\n      .then(function (texture) {\n        texture.flipY = false\n\n        texture.name = textureDef.name || sourceDef.name || ''\n\n        if (\n          texture.name === '' &&\n          typeof sourceDef.uri === 'string' &&\n          sourceDef.uri.startsWith('data:image/') === false\n        ) {\n          texture.name = sourceDef.uri\n        }\n\n        const samplers = json.samplers || {}\n        const sampler = samplers[textureDef.sampler] || {}\n\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter\n        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping\n\n        parser.associations.set(texture, { textures: textureIndex })\n\n        return texture\n      })\n      .catch(function () {\n        return null\n      })\n\n    this.textureCache[cacheKey] = promise\n\n    return promise\n  }\n\n  loadImageSource(sourceIndex, loader) {\n    const parser = this\n    const json = this.json\n    const options = this.options\n\n    if (this.sourceCache[sourceIndex] !== undefined) {\n      return this.sourceCache[sourceIndex].then((texture) => texture.clone())\n    }\n\n    const sourceDef = json.images[sourceIndex]\n\n    const URL = self.URL || self.webkitURL\n\n    let sourceURI = sourceDef.uri || ''\n    let isObjectURL = false\n\n    if (sourceDef.bufferView !== undefined) {\n      // Load binary image data from bufferView, if provided.\n\n      sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function (bufferView) {\n        isObjectURL = true\n        const blob = new Blob([bufferView], { type: sourceDef.mimeType })\n        sourceURI = URL.createObjectURL(blob)\n        return sourceURI\n      })\n    } else if (sourceDef.uri === undefined) {\n      throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')\n    }\n\n    const promise = Promise.resolve(sourceURI)\n      .then(function (sourceURI) {\n        return new Promise(function (resolve, reject) {\n          let onLoad = resolve\n\n          if (loader.isImageBitmapLoader === true) {\n            onLoad = function (imageBitmap) {\n              const texture = new Texture(imageBitmap)\n              texture.needsUpdate = true\n\n              resolve(texture)\n            }\n          }\n\n          loader.load(LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)\n        })\n      })\n      .then(function (texture) {\n        // Clean up resources and configure Texture.\n\n        if (isObjectURL === true) {\n          URL.revokeObjectURL(sourceURI)\n        }\n\n        assignExtrasToUserData(texture, sourceDef)\n\n        texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)\n\n        return texture\n      })\n      .catch(function (error) {\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI)\n        throw error\n      })\n\n    this.sourceCache[sourceIndex] = promise\n    return promise\n  }\n\n  /**\n   * Asynchronously assigns a texture to the given material parameters.\n   * @param {Object} materialParams\n   * @param {string} mapName\n   * @param {Object} mapDef\n   * @return {Promise<Texture>}\n   */\n  assignTexture(materialParams, mapName, mapDef, colorSpace) {\n    const parser = this\n\n    return this.getDependency('texture', mapDef.index).then(function (texture) {\n      if (!texture) return null\n\n      if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {\n        texture = texture.clone()\n        texture.channel = mapDef.texCoord\n      }\n\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform =\n          mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined\n\n        if (transform) {\n          const gltfReference = parser.associations.get(texture)\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform)\n          parser.associations.set(texture, gltfReference)\n        }\n      }\n\n      if (colorSpace !== undefined) {\n        // Convert from legacy encoding to colorSpace\n        if (typeof colorSpace === 'number')\n          colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace\n\n        // Set colorSpace if able, fallback to legacy encoding\n        if ('colorSpace' in texture) texture.colorSpace = colorSpace\n        else texture.encoding = colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding\n      }\n\n      materialParams[mapName] = texture\n\n      return texture\n    })\n  }\n\n  /**\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\n   * already has a material (generated from the glTF material options alone)\n   * but reuse of the same glTF material may require multiple threejs materials\n   * to accommodate different primitive types, defines, etc. New materials will\n   * be created if necessary, and reused from a cache.\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\n   */\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry\n    let material = mesh.material\n\n    const useDerivativeTangents = geometry.attributes.tangent === undefined\n    const useVertexColors = geometry.attributes.color !== undefined\n    const useFlatShading = geometry.attributes.normal === undefined\n\n    if (mesh.isPoints) {\n      const cacheKey = 'PointsMaterial:' + material.uuid\n\n      let pointsMaterial = this.cache.get(cacheKey)\n\n      if (!pointsMaterial) {\n        pointsMaterial = new PointsMaterial()\n        Material.prototype.copy.call(pointsMaterial, material)\n        pointsMaterial.color.copy(material.color)\n        pointsMaterial.map = material.map\n        pointsMaterial.sizeAttenuation = false // glTF spec says points should be 1px\n\n        this.cache.add(cacheKey, pointsMaterial)\n      }\n\n      material = pointsMaterial\n    } else if (mesh.isLine) {\n      const cacheKey = 'LineBasicMaterial:' + material.uuid\n\n      let lineMaterial = this.cache.get(cacheKey)\n\n      if (!lineMaterial) {\n        lineMaterial = new LineBasicMaterial()\n        Material.prototype.copy.call(lineMaterial, material)\n        lineMaterial.color.copy(material.color)\n        lineMaterial.map = material.map\n\n        this.cache.add(cacheKey, lineMaterial)\n      }\n\n      material = lineMaterial\n    }\n\n    // Clone the material if it will be modified\n    if (useDerivativeTangents || useVertexColors || useFlatShading) {\n      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'\n\n      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'\n      if (useVertexColors) cacheKey += 'vertex-colors:'\n      if (useFlatShading) cacheKey += 'flat-shading:'\n\n      let cachedMaterial = this.cache.get(cacheKey)\n\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone()\n\n        if (useVertexColors) cachedMaterial.vertexColors = true\n        if (useFlatShading) cachedMaterial.flatShading = true\n\n        if (useDerivativeTangents) {\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1\n          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1\n        }\n\n        this.cache.add(cacheKey, cachedMaterial)\n\n        this.associations.set(cachedMaterial, this.associations.get(material))\n      }\n\n      material = cachedMaterial\n    }\n\n    mesh.material = material\n  }\n\n  getMaterialType(/* materialIndex */) {\n    return MeshStandardMaterial\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n   * @param {number} materialIndex\n   * @return {Promise<Material>}\n   */\n  loadMaterial(materialIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n    const materialDef = json.materials[materialIndex]\n\n    let materialType\n    const materialParams = {}\n    const materialExtensions = materialDef.extensions || {}\n\n    const pending = []\n\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]\n      materialType = kmuExtension.getMaterialType()\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))\n    } else {\n      // Specification:\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {}\n\n      materialParams.color = new Color(1.0, 1.0, 1.0)\n      materialParams.opacity = 1.0\n\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor\n\n        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace)\n        materialParams.opacity = array[3]\n      }\n\n      if (metallicRoughness.baseColorTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace))\n      }\n\n      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0\n      materialParams.roughness =\n        metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0\n\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\n        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture))\n        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))\n      }\n\n      materialType = this._invokeOne(function (ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex)\n      })\n\n      pending.push(\n        Promise.all(\n          this._invokeAll(function (ext) {\n            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)\n          }),\n        ),\n      )\n    }\n\n    if (materialDef.doubleSided === true) {\n      materialParams.side = DoubleSide\n    }\n\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE\n\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true\n\n      // See: https://github.com/mrdoob/three.js/issues/17706\n      materialParams.depthWrite = false\n    } else {\n      materialParams.transparent = false\n\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5\n      }\n    }\n\n    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture))\n\n      materialParams.normalScale = new Vector2(1, 1)\n\n      if (materialDef.normalTexture.scale !== undefined) {\n        const scale = materialDef.normalTexture.scale\n\n        materialParams.normalScale.set(scale, scale)\n      }\n    }\n\n    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture))\n\n      if (materialDef.occlusionTexture.strength !== undefined) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength\n      }\n    }\n\n    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {\n      const emissiveFactor = materialDef.emissiveFactor\n      materialParams.emissive = new Color().setRGB(\n        emissiveFactor[0],\n        emissiveFactor[1],\n        emissiveFactor[2],\n        LinearSRGBColorSpace,\n      )\n    }\n\n    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace))\n    }\n\n    return Promise.all(pending).then(function () {\n      const material = new materialType(materialParams)\n\n      if (materialDef.name) material.name = materialDef.name\n\n      assignExtrasToUserData(material, materialDef)\n\n      parser.associations.set(material, { materials: materialIndex })\n\n      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef)\n\n      return material\n    })\n  }\n\n  /** When Object3D instances are targeted by animation, they need unique names. */\n  createUniqueName(originalName) {\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')\n\n    if (sanitizedName in this.nodeNamesUsed) {\n      return sanitizedName + '_' + ++this.nodeNamesUsed[sanitizedName]\n    } else {\n      this.nodeNamesUsed[sanitizedName] = 0\n\n      return sanitizedName\n    }\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n   *\n   * Creates BufferGeometries from primitives.\n   *\n   * @param {Array<GLTF.Primitive>} primitives\n   * @return {Promise<Array<BufferGeometry>>}\n   */\n  loadGeometries(primitives) {\n    const parser = this\n    const extensions = this.extensions\n    const cache = this.primitiveCache\n\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\n        .decodePrimitive(primitive, parser)\n        .then(function (geometry) {\n          return addPrimitiveAttributes(geometry, primitive, parser)\n        })\n    }\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i]\n      const cacheKey = createPrimitiveKey(primitive)\n\n      // See if we've already created this geometry\n      const cached = cache[cacheKey]\n\n      if (cached) {\n        // Use the cached geometry if it exists\n        pending.push(cached.promise)\n      } else {\n        let geometryPromise\n\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          // Use DRACO geometry if available\n          geometryPromise = createDracoPrimitive(primitive)\n        } else {\n          // Otherwise create a new geometry\n          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser)\n        }\n\n        // Cache this geometry\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise }\n\n        pending.push(geometryPromise)\n      }\n    }\n\n    return Promise.all(pending)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n   * @param {number} meshIndex\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\n   */\n  loadMesh(meshIndex) {\n    const parser = this\n    const json = this.json\n    const extensions = this.extensions\n\n    const meshDef = json.meshes[meshIndex]\n    const primitives = meshDef.primitives\n\n    const pending = []\n\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material =\n        primitives[i].material === undefined\n          ? createDefaultMaterial(this.cache)\n          : this.getDependency('material', primitives[i].material)\n\n      pending.push(material)\n    }\n\n    pending.push(parser.loadGeometries(primitives))\n\n    return Promise.all(pending).then(function (results) {\n      const materials = results.slice(0, results.length - 1)\n      const geometries = results[results.length - 1]\n\n      const meshes = []\n\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i]\n        const primitive = primitives[i]\n\n        // 1. create Mesh\n\n        let mesh\n\n        const material = materials[i]\n\n        if (\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n          primitive.mode === undefined\n        ) {\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\n          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material)\n\n          if (mesh.isSkinnedMesh === true) {\n            // normalize skin weights to fix malformed assets (see #15319)\n            mesh.normalizeSkinWeights()\n          }\n\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode)\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode)\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new LineSegments(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new Line(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new LineLoop(geometry, material)\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new Points(geometry, material)\n        } else {\n          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)\n        }\n\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef)\n        }\n\n        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)\n\n        assignExtrasToUserData(mesh, meshDef)\n\n        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive)\n\n        parser.assignFinalMaterial(mesh)\n\n        meshes.push(mesh)\n      }\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        parser.associations.set(meshes[i], {\n          meshes: meshIndex,\n          primitives: i,\n        })\n      }\n\n      if (meshes.length === 1) {\n        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef)\n\n        return meshes[0]\n      }\n\n      const group = new Group()\n\n      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef)\n\n      parser.associations.set(group, { meshes: meshIndex })\n\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i])\n      }\n\n      return group\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n   * @param {number} cameraIndex\n   * @return {Promise<THREE.Camera>}\n   */\n  loadCamera(cameraIndex) {\n    let camera\n    const cameraDef = this.json.cameras[cameraIndex]\n    const params = cameraDef[cameraDef.type]\n\n    if (!params) {\n      console.warn('THREE.GLTFLoader: Missing camera parameters.')\n      return\n    }\n\n    if (cameraDef.type === 'perspective') {\n      camera = new PerspectiveCamera(\n        MathUtils.radToDeg(params.yfov),\n        params.aspectRatio || 1,\n        params.znear || 1,\n        params.zfar || 2e6,\n      )\n    } else if (cameraDef.type === 'orthographic') {\n      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)\n    }\n\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)\n\n    assignExtrasToUserData(camera, cameraDef)\n\n    return Promise.resolve(camera)\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n   * @param {number} skinIndex\n   * @return {Promise<Skeleton>}\n   */\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex]\n\n    const pending = []\n\n    for (let i = 0, il = skinDef.joints.length; i < il; i++) {\n      pending.push(this._loadNodeShallow(skinDef.joints[i]))\n    }\n\n    if (skinDef.inverseBindMatrices !== undefined) {\n      pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))\n    } else {\n      pending.push(null)\n    }\n\n    return Promise.all(pending).then(function (results) {\n      const inverseBindMatrices = results.pop()\n      const jointNodes = results\n\n      // Note that bones (joint nodes) may or may not be in the\n      // scene graph at this time.\n\n      const bones = []\n      const boneInverses = []\n\n      for (let i = 0, il = jointNodes.length; i < il; i++) {\n        const jointNode = jointNodes[i]\n\n        if (jointNode) {\n          bones.push(jointNode)\n\n          const mat = new Matrix4()\n\n          if (inverseBindMatrices !== null) {\n            mat.fromArray(inverseBindMatrices.array, i * 16)\n          }\n\n          boneInverses.push(mat)\n        } else {\n          console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[i])\n        }\n      }\n\n      return new Skeleton(bones, boneInverses)\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n   * @param {number} animationIndex\n   * @return {Promise<AnimationClip>}\n   */\n  loadAnimation(animationIndex) {\n    const json = this.json\n    const parser = this\n\n    const animationDef = json.animations[animationIndex]\n    const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex\n\n    const pendingNodes = []\n    const pendingInputAccessors = []\n    const pendingOutputAccessors = []\n    const pendingSamplers = []\n    const pendingTargets = []\n\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i]\n      const sampler = animationDef.samplers[channel.sampler]\n      const target = channel.target\n      const name = target.node\n      const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input\n      const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output\n\n      if (target.node === undefined) continue\n\n      pendingNodes.push(this.getDependency('node', name))\n      pendingInputAccessors.push(this.getDependency('accessor', input))\n      pendingOutputAccessors.push(this.getDependency('accessor', output))\n      pendingSamplers.push(sampler)\n      pendingTargets.push(target)\n    }\n\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets),\n    ]).then(function (dependencies) {\n      const nodes = dependencies[0]\n      const inputAccessors = dependencies[1]\n      const outputAccessors = dependencies[2]\n      const samplers = dependencies[3]\n      const targets = dependencies[4]\n\n      const tracks = []\n\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i]\n        const inputAccessor = inputAccessors[i]\n        const outputAccessor = outputAccessors[i]\n        const sampler = samplers[i]\n        const target = targets[i]\n\n        if (node === undefined) continue\n\n        if (node.updateMatrix) {\n          node.updateMatrix()\n        }\n\n        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target)\n\n        if (createdTracks) {\n          for (let k = 0; k < createdTracks.length; k++) {\n            tracks.push(createdTracks[k])\n          }\n        }\n      }\n\n      return new AnimationClip(animationName, undefined, tracks)\n    })\n  }\n\n  createNodeMesh(nodeIndex) {\n    const json = this.json\n    const parser = this\n    const nodeDef = json.nodes[nodeIndex]\n\n    if (nodeDef.mesh === undefined) return null\n\n    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)\n\n      // if weights are provided on the node, override weights on the mesh.\n      if (nodeDef.weights !== undefined) {\n        node.traverse(function (o) {\n          if (!o.isMesh) return\n\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i]\n          }\n        })\n      }\n\n      return node\n    })\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n   * @param {number} nodeIndex\n   * @return {Promise<Object3D>}\n   */\n  loadNode(nodeIndex) {\n    const json = this.json\n    const parser = this\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    const nodePending = parser._loadNodeShallow(nodeIndex)\n\n    const childPending = []\n    const childrenDef = nodeDef.children || []\n\n    for (let i = 0, il = childrenDef.length; i < il; i++) {\n      childPending.push(parser.getDependency('node', childrenDef[i]))\n    }\n\n    const skeletonPending =\n      nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin)\n\n    return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function (results) {\n      const node = results[0]\n      const children = results[1]\n      const skeleton = results[2]\n\n      if (skeleton !== null) {\n        // This full traverse should be fine because\n        // child glTF nodes have not been added to this node yet.\n        node.traverse(function (mesh) {\n          if (!mesh.isSkinnedMesh) return\n\n          mesh.bind(skeleton, _identityMatrix)\n        })\n      }\n\n      for (let i = 0, il = children.length; i < il; i++) {\n        node.add(children[i])\n      }\n\n      return node\n    })\n  }\n\n  // ._loadNodeShallow() parses a single node.\n  // skin and child nodes are created and added in .loadNode() (no '_' prefix).\n  _loadNodeShallow(nodeIndex) {\n    const json = this.json\n    const extensions = this.extensions\n    const parser = this\n\n    // This method is called from .loadNode() and .loadSkin().\n    // Cache a node to avoid duplication.\n\n    if (this.nodeCache[nodeIndex] !== undefined) {\n      return this.nodeCache[nodeIndex]\n    }\n\n    const nodeDef = json.nodes[nodeIndex]\n\n    // reserve node's name before its dependencies, so the root has the intended name.\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''\n\n    const pending = []\n\n    const meshPromise = parser._invokeOne(function (ext) {\n      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)\n    })\n\n    if (meshPromise) {\n      pending.push(meshPromise)\n    }\n\n    if (nodeDef.camera !== undefined) {\n      pending.push(\n        parser.getDependency('camera', nodeDef.camera).then(function (camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)\n        }),\n      )\n    }\n\n    parser\n      ._invokeAll(function (ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\n      })\n      .forEach(function (promise) {\n        pending.push(promise)\n      })\n\n    this.nodeCache[nodeIndex] = Promise.all(pending).then(function (objects) {\n      let node\n\n      // .isBone isn't in glTF spec. See ._markDefs\n      if (nodeDef.isBone === true) {\n        node = new Bone()\n      } else if (objects.length > 1) {\n        node = new Group()\n      } else if (objects.length === 1) {\n        node = objects[0]\n      } else {\n        node = new Object3D()\n      }\n\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i])\n        }\n      }\n\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name\n        node.name = nodeName\n      }\n\n      assignExtrasToUserData(node, nodeDef)\n\n      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef)\n\n      if (nodeDef.matrix !== undefined) {\n        const matrix = new Matrix4()\n        matrix.fromArray(nodeDef.matrix)\n        node.applyMatrix4(matrix)\n      } else {\n        if (nodeDef.translation !== undefined) {\n          node.position.fromArray(nodeDef.translation)\n        }\n\n        if (nodeDef.rotation !== undefined) {\n          node.quaternion.fromArray(nodeDef.rotation)\n        }\n\n        if (nodeDef.scale !== undefined) {\n          node.scale.fromArray(nodeDef.scale)\n        }\n      }\n\n      if (!parser.associations.has(node)) {\n        parser.associations.set(node, {})\n      }\n\n      parser.associations.get(node).nodes = nodeIndex\n\n      return node\n    })\n\n    return this.nodeCache[nodeIndex]\n  }\n\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n   * @param {number} sceneIndex\n   * @return {Promise<Group>}\n   */\n  loadScene(sceneIndex) {\n    const extensions = this.extensions\n    const sceneDef = this.json.scenes[sceneIndex]\n    const parser = this\n\n    // Loader returns Group, not Scene.\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\n    const scene = new Group()\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)\n\n    assignExtrasToUserData(scene, sceneDef)\n\n    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef)\n\n    const nodeIds = sceneDef.nodes || []\n\n    const pending = []\n\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(parser.getDependency('node', nodeIds[i]))\n    }\n\n    return Promise.all(pending).then(function (nodes) {\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        scene.add(nodes[i])\n      }\n\n      // Removes dangling associations, associations that reference a node that\n      // didn't make it into the scene.\n      const reduceAssociations = (node) => {\n        const reducedAssociations = new Map()\n\n        for (const [key, value] of parser.associations) {\n          if (key instanceof Material || key instanceof Texture) {\n            reducedAssociations.set(key, value)\n          }\n        }\n\n        node.traverse((node) => {\n          const mappings = parser.associations.get(node)\n\n          if (mappings != null) {\n            reducedAssociations.set(node, mappings)\n          }\n        })\n\n        return reducedAssociations\n      }\n\n      parser.associations = reduceAssociations(scene)\n\n      return scene\n    })\n  }\n\n  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {\n    const tracks = []\n\n    const targetName = node.name ? node.name : node.uuid\n    const targetNames = []\n\n    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n      node.traverse(function (object) {\n        if (object.morphTargetInfluences) {\n          targetNames.push(object.name ? object.name : object.uuid)\n        }\n      })\n    } else {\n      targetNames.push(targetName)\n    }\n\n    let TypedKeyframeTrack\n\n    switch (PATH_PROPERTIES[target.path]) {\n      case PATH_PROPERTIES.weights:\n        TypedKeyframeTrack = NumberKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.rotation:\n        TypedKeyframeTrack = QuaternionKeyframeTrack\n        break\n\n      case PATH_PROPERTIES.position:\n      case PATH_PROPERTIES.scale:\n        TypedKeyframeTrack = VectorKeyframeTrack\n        break\n\n      default:\n        switch (outputAccessor.itemSize) {\n          case 1:\n            TypedKeyframeTrack = NumberKeyframeTrack\n            break\n          case 2:\n          case 3:\n          default:\n            TypedKeyframeTrack = VectorKeyframeTrack\n            break\n        }\n\n        break\n    }\n\n    const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear\n\n    const outputArray = this._getArrayFromAccessor(outputAccessor)\n\n    for (let j = 0, jl = targetNames.length; j < jl; j++) {\n      const track = new TypedKeyframeTrack(\n        targetNames[j] + '.' + PATH_PROPERTIES[target.path],\n        inputAccessor.array,\n        outputArray,\n        interpolation,\n      )\n\n      // Override interpolation with custom factory method.\n      if (sampler.interpolation === 'CUBICSPLINE') {\n        this._createCubicSplineTrackInterpolant(track)\n      }\n\n      tracks.push(track)\n    }\n\n    return tracks\n  }\n\n  _getArrayFromAccessor(accessor) {\n    let outputArray = accessor.array\n\n    if (accessor.normalized) {\n      const scale = getNormalizedComponentScale(outputArray.constructor)\n      const scaled = new Float32Array(outputArray.length)\n\n      for (let j = 0, jl = outputArray.length; j < jl; j++) {\n        scaled[j] = outputArray[j] * scale\n      }\n\n      outputArray = scaled\n    }\n\n    return outputArray\n  }\n\n  _createCubicSplineTrackInterpolant(track) {\n    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n      // A CUBICSPLINE keyframe in glTF has three output values for each input value,\n      // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n      // must be divided by three to get the interpolant's sampleSize argument.\n\n      const interpolantType =\n        this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant\n\n      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)\n    }\n\n    // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\n    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true\n  }\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n */\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const box = new Box3()\n\n  if (attributes.POSITION !== undefined) {\n    const accessor = parser.json.accessors[attributes.POSITION]\n\n    const min = accessor.min\n    const max = accessor.max\n\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n    if (min !== undefined && max !== undefined) {\n      box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]))\n\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n        box.min.multiplyScalar(boxScale)\n        box.max.multiplyScalar(boxScale)\n      }\n    } else {\n      console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n\n      return\n    }\n  } else {\n    return\n  }\n\n  const targets = primitiveDef.targets\n\n  if (targets !== undefined) {\n    const maxDisplacement = new Vector3()\n    const vector = new Vector3()\n\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i]\n\n      if (target.POSITION !== undefined) {\n        const accessor = parser.json.accessors[target.POSITION]\n        const min = accessor.min\n        const max = accessor.max\n\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\n\n        if (min !== undefined && max !== undefined) {\n          // we need to get max of absolute components because target weight is [-1,1]\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))\n\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType])\n            vector.multiplyScalar(boxScale)\n          }\n\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\n          maxDisplacement.max(vector)\n        } else {\n          console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')\n        }\n      }\n    }\n\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\n    box.expandByVector(maxDisplacement)\n  }\n\n  geometry.boundingBox = box\n\n  const sphere = new Sphere()\n\n  box.getCenter(sphere.center)\n  sphere.radius = box.min.distanceTo(box.max) / 2\n\n  geometry.boundingSphere = sphere\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {GLTF.Primitive} primitiveDef\n * @param {GLTFParser} parser\n * @return {Promise<BufferGeometry>}\n */\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes\n\n  const pending = []\n\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {\n      geometry.setAttribute(attributeName, accessor)\n    })\n  }\n\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()\n\n    // Skip attributes already provided by e.g. Draco extension.\n    if (threeAttributeName in geometry.attributes) continue\n\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))\n  }\n\n  if (primitiveDef.indices !== undefined && !geometry.index) {\n    const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {\n      geometry.setIndex(accessor)\n    })\n\n    pending.push(accessor)\n  }\n\n  assignExtrasToUserData(geometry, primitiveDef)\n\n  computeBounds(geometry, primitiveDef, parser)\n\n  return Promise.all(pending).then(function () {\n    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry\n  })\n}\n\nexport { GLTFLoader }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { GLTFLoader, DRACOLoader, MeshoptDecoder } from 'three-stdlib';\nimport { useLoader } from '@react-three/fiber';\nimport { Clone } from './Clone.js';\n\nlet dracoLoader = null;\nlet decoderPath = 'https://www.gstatic.com/draco/versioned/decoders/1.5.5/';\nfunction extensions(useDraco = true, useMeshopt = true, extendLoader) {\n  return loader => {\n    if (extendLoader) {\n      extendLoader(loader);\n    }\n    if (useDraco) {\n      if (!dracoLoader) {\n        dracoLoader = new DRACOLoader();\n      }\n      dracoLoader.setDecoderPath(typeof useDraco === 'string' ? useDraco : decoderPath);\n      loader.setDRACOLoader(dracoLoader);\n    }\n    if (useMeshopt) {\n      loader.setMeshoptDecoder(typeof MeshoptDecoder === 'function' ? MeshoptDecoder() : MeshoptDecoder);\n    }\n  };\n}\nconst useGLTF = (path, useDraco, useMeshopt, extendLoader) => useLoader(GLTFLoader, path, extensions(useDraco, useMeshopt, extendLoader));\nuseGLTF.preload = (path, useDraco, useMeshopt, extendLoader) => useLoader.preload(GLTFLoader, path, extensions(useDraco, useMeshopt, extendLoader));\nuseGLTF.clear = path => useLoader.clear(GLTFLoader, path);\nuseGLTF.setDecoderPath = path => {\n  decoderPath = path;\n};\n\n//\n\nconst Gltf = /* @__PURE__ */React.forwardRef(({\n  src,\n  useDraco,\n  useMeshOpt,\n  extendLoader,\n  ...props\n}, ref) => {\n  const {\n    scene\n  } = useGLTF(src, useDraco, useMeshOpt, extendLoader);\n  return /*#__PURE__*/React.createElement(Clone, _extends({\n    ref: ref\n  }, props, {\n    object: scene\n  }));\n});\n\nexport { Gltf, useGLTF };\n","import { REVISION } from 'three'\n\nexport const version = /* @__PURE__ */ (() => parseInt(REVISION.replace(/\\D+/g, '')))()\n"],"names":["useAnimations","clips","root","ref","React","actualRef","Object3D","current","mixer","AnimationMixer","undefined","_root","lazyActions","api","actions","forEach","clip","Object","defineProperty","name","enumerable","get","clipAction","configurable","names","map","c","useFrame","state","delta","update","currentRoot","stopAllAction","values","action","uncacheAction","_extends","assign","bind","n","e","arguments","length","t","r","hasOwnProperty","call","apply","GroundProjectedEnv","Mesh","constructor","texture","options","isCubeMap","def","isCubeTexture","cubeSize","_b","_a","image","width","_lodMax","Math","floor","log2","_cubeSize","pow","fragmentShader","max","join","version","uniforms","value","height","radius","super","IcosahedronGeometry","ShaderMaterial","vertexShader","side","DoubleSide","material","this","RGBELoader","DataTextureLoader","manager","type","HalfFloatType","parse","buffer","rgbe_error","rgbe_error_code","msg","Error","fgets","buffer2","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","Uint16Array","subarray","indexOf","byteLength","slice","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","scale","RGBEByteToRGBHalf","DataUtils","toHalfFloat","min","byteArray","Uint8Array","rgbe_header_info","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","line","match","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","h","image_rgba_data","w2","h2","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","count","ptr","isEncodedRun","byteValue","set","l","off","RGBE_ReadPixels_RLE","data","numElements","FloatType","floatArray","Float32Array","j","halfArray","setDataType","load","url","onLoad","onProgress","onError","texData","colorSpace","encoding","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","u8","u16","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","b","fl","revfl","fd","rev","x","hMap","cd","mb","co","le","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","a","bits","d","o","bits16","shft","slc","inflt","dat","buf","st","sl","noBuf","noSt","cbuf","bl","nbuf","final","f","bt","lm","dm","lbt","dbt","tbts","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","lt","dt","lms","dms","lpos","sym","add","dsym","end","et","zlv","unzlibSync","out","td","TextDecoder","decode","stream","hasColorSpace","EXRLoader","USHORT_RANGE","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","logBase","getBitsReturn","lc","getBits","nBits","uInt8Array2","inOffset","parseUint8Array","hufTableBuffer","Array","hufUnpackEncTable","inDataView","ni","im","iM","hcode","zerun","nc","hufCanonicalCodeTable","hufLength","code","hufCode","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","UInt16","Int16","wdec14Return","wdec14","ls","hs","ai","as","bs","wdec16","bb","aa","wav2Decode","nx","ox","ny","oy","mx","p2","w14","i00","i01","i10","i11","py","ey","oy1","oy2","ox1","ox2","px","ex","p01","p11","p10","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","hdec","lit","hufClearDecTable","hdecod","pl","plOffset","hufBuildDecTable","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","hufDecode","predictor","source","interleaveScalar","t1","t2","stop","decodeRunLength","size","reader","DataView","getInt8","push","getUint8","unRleAC","currAcComp","acBuffer","halfZigBlock","acValue","dctComp","unZigZag","src","dst","decodeFloat16","dctInverse","cos","g","alpha","beta","theta","row","rowPtr","column","csc709Inverse","y","cb","cr","convertToHalf","idx","toLinear","float","sign","abs","uncompressRAW","info","array","uncompressRLE","compressed","viewer","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","channels","bitmap","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","lut","maxValue","k","reverseLutFromBitmap","nData","applyLut","tmpOffset2","cp","uncompressPXR","sz","tmpBufferEnd","writePtr","pixel","uncompressDWA","dwaHeader","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","parseNullTerminatedString","index","Int8Array","channelData","channel","decoded","pixelType","pLinear","cscSet","offset2","rule","zlibInfo","dcBuffer","rleBuffer","rowOffsets","chan","rowPtrs","dataView","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currDcComp","dctData","rowBlock","comp2","blocky","maxY","maxX","blockx","fill","type2","y2","setUint16","offset3","x2","halfRow","comp","getUint16","setFloat32","lossyDctDecode","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","parseInt32","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseValue","parseFixedLengthString","startOffset","xSampling","ySampling","parseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseChromaticities","parseCompression","xMin","yMin","xMax","yMax","parseBox2i","parseLineOrder","parseV2f","parseV3f","parseRational","parseTimecode","bufferDataView","uInt8Array","EXRHeader2","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeValue","console","warn","error","parseHeader","EXRDecoder","outputType","EXRDecoder2","dataWindow","bytesPerLine","inputSize","uncompress","getter","blockCount","outputChannels","RGBAFormat","RedFormat","setupDecoder","tmpOffset","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line_y","true_y","channelID","cOff","outIndex","getBufferForType","UnsignedByteType","Uint8ClampedArray","UnsignedIntType","ByteType","ShortType","Int16Array","IntType","Int32Array","_canReadPixelsResult","QuadRenderer","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_rendererIsDisposable","_supportsReadPixels","render","_renderer","setRenderTarget","_renderTarget","_scene","_camera","_width","_height","_type","_colorSpace","rtOptions","depthBuffer","stencilBuffer","anisotropy","renderTargetOptions","samples","wrapS","ClampToEdgeWrapping","wrapT","_material","renderer","instantiateRenderer","Scene","OrthographicCamera","position","left","right","top","bottom","updateProjectionMatrix","canReadPixels","camera","testRT","WebGLRenderTarget","mesh","PlaneGeometry","MeshBasicMaterial","color","readRenderTargetPixels","dispose","geometry","alternativeType","extensions","has","_quad","computeBoundingBox","mapping","UVMapping","WebGLRenderer","setSize","toArray","toDataTexture","returnValue","DataTexture","LinearSRGBColorSpace","disposeOnDemandRenderer","forceContextLoss","disposeRenderTarget","renderTarget","Texture","GainMapDecoderMaterial","_ref","offsetHdr","offsetSdr","gainMapMin","gainMapMax","maxDisplayBoost","hdrCapacityMin","hdrCapacityMax","sdr","gainMap","Vector3","fromArray","weightFactor","blending","NoBlending","depthTest","depthWrite","_maxDisplayBoost","_hdrCapacityMin","_hdrCapacityMax","needsUpdate","uniformsNeedUpdate","z","calculateWeight","val","GainMapNotFoundError","XMPMetadataNotFoundError","getXMLValue","xml","tag","defaultValue","attributeMatch","RegExp","exec","tagMatch","liValues","replace","trim","MPFExtractor","debug","extractFII","extractNonFII","extract","imageArrayBuffer","Promise","resolve","reject","marker","loops","toString","log","formatPt","tiffOffset","bigEnd","firstIFDOffset","dirStart","entriesStart","numberOfImages","MPImageListValPt","images","MPType","dataOffset","dependantImages","isFII","bufferBlob","Blob","imgs","imageBlob","extractGainmapFromJPEG","async","metadata","input","str","xmpBlock","offsetSDR","offsetHDR","hdrCapacityMinMatch","hdrCapacityMaxMatch","isArray","extractXMP","jpegFile","mpfExtractor","arrayBuffer","getHTMLImageFromBlob","blob","img","document","createElement","onload","onerror","URL","createObjectURL","LoaderBase","Loader","_internalLoadingManager","LoadingManager","setRenderer","setRenderTargetOptions","_renderTargetOptions","prepareQuadRenderer","quadRenderer","sdrBuffer","gainMapBuffer","gainMapBlob","sdrBlob","sdrImage","gainMapImage","needsFlip","createImageBitmap","res","all","imageOrientation","ImageData","LinearMipMapLinearFilter","SRGBColorSpace","GainMapLoader","_ref2","sdrUrl","gainMapUrl","metadataUrl","loadCheck","itemError","itemEnd","sdrLengthComputable","sdrTotal","sdrLoaded","gainMapLengthComputable","gainMapTotal","gainMapLoaded","metadataLengthComputable","metadataTotal","metadataLoaded","progressHandler","ProgressEvent","lengthComputable","loaded","total","itemStart","sdrLoader","FileLoader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","gainMapLoader","metadataLoader","json","JSON","HDRJPGLoader","loader","jpeg","jpegBuffer","sdrJPEG","gainMapJPEG","extractionResult","presetsObj","apartment","city","dawn","forest","lobby","night","park","studio","sunset","warehouse","CUBEMAP_ROOT","arr","defaultFiles","useEnvironment","files","preset","validatePreset","multiFile","extension","isCubemap","getExtension","getLoader","gl","useThree","useLayoutEffect","domElement","addEventListener","useLoader","clear","once","loaderResult","CubeReflectionMapping","EquirectangularReflectionMapping","preloadDefaultOptions","preload","preloadOptions","clearDefaultOptins","keys","_firstEntry$split$pop","isGainmap","some","file","endsWith","firstEntry","startsWith","split","pop","shift","toLowerCase","CubeTextureLoader","clearOptions","resolveScene","scene","isRef","obj","isScene","setEnvProps","background","defaultScene","sceneProps","_target$backgroundRot","_target$backgroundRot2","_target$environmentRo","_target$environmentRo2","backgroundBlurriness","backgroundIntensity","backgroundRotation","environmentIntensity","environmentRotation","target","oldbg","oldenv","environment","oldSceneProps","clone","applyProps","EnvironmentMap","config","EnvironmentCube","blur","rest","EnvironmentPortal","_ref3","children","near","far","resolution","frames","virtualScene","fbo","WebGLCubeRenderTarget","autoClear","createPortal","args","EnvironmentGround","props","_props$ground","_props$ground2","_scale","_props$ground3","textureDefault","extend","GroundProjectedEnvImpl","ground","Environment","_taskCache","WeakMap","DRACOLoader","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","normal","uv","defaultAttributeTypes","setDecoderPath","setDecoderConfig","setWorkerLimit","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","decodeDracoFile","callback","attribute","BYTES_PER_ELEMENT","taskKey","stringify","cachedTask","key","promise","worker","taskID","taskCost","geometryPending","_getWorker","_worker","_callbacks","postMessage","id","message","_createGeometry","_releaseTask","geometryData","BufferGeometry","setIndex","BufferAttribute","attributes","itemSize","setAttribute","_loadLibrary","responseType","_initDecoder","useJS","WebAssembly","librariesPending","libraries","jsContent","wasmBinary","fn","DRACOWorker","body","substring","lastIndexOf","worker2","Worker","_taskCosts","_taskLoad","onmessage","sort","terminate","decodeAttribute","draco","decoder","dracoGeometry","numComponents","num_components","numValues","num_points","dataType","DT_FLOAT32","DT_INT8","DT_INT16","DT_INT32","DT_UINT8","DT_UINT16","DT_UINT32","getDracoDataType","_malloc","GetAttributeDataArrayForAllPoints","HEAPF32","_free","onModuleLoaded","DracoDecoderModule","module","Decoder","decoderBuffer","DecoderBuffer","Init","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","error_msg","self","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","numFaces","num_faces","numIndices","GetTrianglesUInt32Array","decodeIndex","destroy","buffers","attr","generated","MeshoptDecoder","detector","wasmpack","supported","instance","wasm","validate","instantiate","result","ch","charCodeAt","write","unpack","exports","__wasm_call_ctors","fun","filter","sbrk","count4","tp","sp","heap","memory","filters","NONE","OCTAHEDRAL","QUATERNION","EXPONENTIAL","decoders","ATTRIBUTES","TRIANGLES","INDICES","ready","decodeVertexBuffer","meshopt_decodeVertexBuffer","decodeIndexBuffer","meshopt_decodeIndexBuffer","decodeIndexSequence","meshopt_decodeIndexSequence","decodeGltfBuffer","mode","toTrianglesDrawMode","drawMode","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","getIndex","indices","getAttribute","numberOfTriangles","newIndices","getX","newGeometry","clearGroups","decodeText","il","decodeURIComponent","escape","GLTFLoader","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFMaterialsDispersionExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFTextureAVIFExtension","GLTFMaterialsSheenExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsBumpExtension","GLTFLightsExtension","GLTFMeshoptCompression","GLTFMeshGpuInstancing","scope","resourcePath","relativeUrl","LoaderUtils","extractUrlBase","resolveURL","_onError","gltf","setDRACOLoader","setDDSLoader","setKTX2Loader","setMeshoptDecoder","unregister","splice","plugins","ArrayBuffer","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","content","asset","GLTFParser","crossOrigin","fileLoader","plugin","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","setExtensions","setPlugins","parseAsync","GLTFRegistry","objects","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_DISPERSION","KHR_MATERIALS_IOR","KHR_MATERIALS_SHEEN","KHR_MATERIALS_SPECULAR","KHR_MATERIALS_TRANSMISSION","KHR_MATERIALS_IRIDESCENCE","KHR_MATERIALS_ANISOTROPY","KHR_MATERIALS_VOLUME","KHR_TEXTURE_BASISU","KHR_MATERIALS_EMISSIVE_STRENGTH","EXT_MATERIALS_BUMP","EXT_TEXTURE_WEBP","EXT_TEXTURE_AVIF","EXT_MESHOPT_COMPRESSION","EXT_MESH_GPU_INSTANCING","cache","refs","uses","_markDefs","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","_loadLight","lightIndex","cacheKey","dependency","lightDef","lights","lightNode","Color","setRGB","range","DirectionalLight","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","PI","angle","penumbra","decay","assignExtrasToUserData","intensity","createUniqueName","getDependency","createNodeAttachment","self2","_getNodeRef","getMaterialType","extendParams","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","baseColorFactor","baseColorTexture","assignTexture","extendMaterialParams","materialIndex","materials","emissiveStrength","emissiveIntensity","MeshPhysicalMaterial","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","clearcoatNormalScale","Vector2","dispersion","iridescenceFactor","iridescence","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessRange","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceThicknessTexture","sheenColor","sheenRoughness","sheen","sheenColorFactor","colorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","transmissionFactor","transmission","transmissionTexture","thickness","thicknessFactor","thicknessTexture","attenuationDistance","colorArray","attenuationColor","ior","specularIntensity","specularFactor","specularTexture","specularColorFactor","specularColor","specularColorTexture","bumpScale","bumpFactor","bumpTexture","anisotropyStrength","anisotropyRotation","anisotropyTexture","loadTexture","textureIndex","textureDef","textures","loadTextureImage","isSupported","textureLoader","uri","handler","getHandler","detectSupport","Image","loadBufferView","bufferView","bufferViews","extensionDef","byteOffset","stride","byteStride","decodeGltfBufferAsync","res2","createNodeMesh","meshDef","meshes","primitive","primitives","WEBGL_CONSTANTS","TRIANGLE_STRIP","TRIANGLE_FAN","attributesDef","accessor","results","nodeObject","isGroup","instancedMeshes","Matrix4","q","Quaternion","instancedMesh","InstancedMesh","TRANSLATION","fromBufferAttribute","ROTATION","SCALE","setMatrixAt","compose","instanceColor","InstancedBufferAttribute","normalized","copy","assignFinalMaterial","BINARY_EXTENSION_CHUNK_TYPES","headerView","magic","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","decodePrimitive","bufferViewIndex","gltfAttributeMap","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","threeAttributeName","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","extendTexture","transform","texCoord","rotation","repeat","GLTFCubicSplineInterpolant","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","copySampleValue_","valueSize","interpolate_","i1","t0","stride2","stride3","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","GLTFCubicSplineQuaternionInterpolant","normalize","FLOAT","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","LINEAR","REPEAT","SAMPLER_2D","POINTS","LINES","LINE_LOOP","LINE_STRIP","UNSIGNED_BYTE","UNSIGNED_SHORT","WEBGL_FILTERS","NearestFilter","NearestMipmapNearestFilter","LinearMipmapNearestFilter","NearestMipmapLinearFilter","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","MirroredRepeatWrapping","RepeatWrapping","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","TEXCOORD_2","TEXCOORD_3","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","gltfDef","extras","updateMorphTargets","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","geometryKey","dracoExtension","createAttributesKey","targets","attributesKey","getNormalizedComponentScale","_identityMatrix","associations","Map","primitiveCache","nodeCache","meshCache","cameraCache","lightCache","sourceCache","textureCache","nodeNamesUsed","isSafari","isFirefox","firefoxVersion","navigator","userAgent","test","TextureLoader","ImageBitmapLoader","setCrossOrigin","_invokeAll","ext","beforeRoot","getDependencies","dependencies","scenes","animations","cameras","afterRoot","updateMatrixWorld","skinDefs","skins","meshDefs","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","updateMappings","original","mappings","child","entries","_invokeOne","func","unshift","loadScene","loadNode","loadMesh","loadAccessor","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","bufferIndex","bufferDef","bufferViewDef","accessorIndex","sparse","TypedArray","pendingBufferViews","elementBytes","itemBytes","bufferAttribute","ibSlice","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sourceIndex","sourceDef","sampler","loadImageSource","samplers","webkitURL","sourceURI","isObjectURL","mimeType","sourceURI2","isImageBitmapLoader","imageBitmap","revokeObjectURL","search","mapName","mapDef","gltfReference","useDerivativeTangents","tangent","useVertexColors","useFlatShading","isPoints","uuid","pointsMaterial","PointsMaterial","Material","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","normalScale","MeshStandardMaterial","materialType","kmuExtension","metalness","metallicFactor","roughness","roughnessFactor","metallicRoughnessTexture","doubleSided","alphaMode","transparent","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","aoMapIntensity","emissiveFactor","emissive","emissiveTexture","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","loadGeometries","createDracoPrimitive","addPrimitiveAttributes","cached","geometryPromise","meshIndex","FrontSide","geometries","SkinnedMesh","normalizeSkinWeights","LineSegments","Line","LineLoop","Points","morphAttributes","group","Group","cameraIndex","cameraDef","params","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","xmag","ymag","skinDef","_loadNodeShallow","inverseBindMatrices","jointNodes","bones","boneInverses","jointNode","mat","Skeleton","animationIndex","animationDef","animationName","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","node","parameters","output","inputAccessors","outputAccessors","tracks","inputAccessor","outputAccessor","updateMatrix","createdTracks","_createAnimationTracks","AnimationClip","traverse","isMesh","nodePending","childPending","childrenDef","skeletonPending","skeleton","nodeName","meshPromise","Bone","matrix","applyMatrix4","quaternion","sceneIndex","sceneDef","nodeIds","reducedAssociations","node2","reduceAssociations","targetName","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","interpolation","outputArray","_getArrayFromAccessor","jl","track","_createCubicSplineTrackInterpolant","scaled","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","assignAttributeAccessor","gltfAttributeName","accessor2","box","Box3","boxScale","multiplyScalar","maxDisplacement","vector","expandByVector","boundingBox","sphere","Sphere","getCenter","center","distanceTo","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","hasMorphColor","pendingPositionAccessors","pendingNormalAccessors","pendingColorAccessors","pendingAccessor","morphPositions","morphNormals","morphColors","morphTargetsRelative","addMorphTargets","useDraco","useMeshopt","extendLoader","useGLTF","REVISION"],"sourceRoot":""}